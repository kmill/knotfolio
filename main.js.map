{"version":3,"file":"main.js","sources":["../src/util.mjs","../src/integers.mjs","../src/kq.mjs","../src/poly.mjs","../src/laurent.mjs","../src/pd.mjs","../src/geom2d.mjs","../src/knotgraph.mjs","../src/tl.mjs","../src/invariants.mjs","../src/matrix.mjs","../src/jones.mjs","../src/fga.mjs","../src/alexander.mjs","../src/ratfun.mjs","../src/conway.mjs","../src/knotdata.mjs","../src/identify.mjs","../src/constants.mjs","../src/KnotDiagramView.mjs","../src/KnotRasterView.mjs","../src/StackBlur.mjs","../src/KnotImageImportView.mjs","../src/undostack.mjs","../src/main.mjs"],"sourcesContent":["export function assert(b) {\n  /* Asserts that the argument is true. */\n  if (!b) {\n    debugger;\n    throw new Error(\"assertion failed\");\n  }\n}\nexport function assert_fails(f) {\n  try {\n    f();\n  } catch (x) {\n    return;\n  }\n  debugger;\n  throw new Error(\"assertion failed\");\n}\n\nexport function test(name, f) {\n  try {\n    f();\n  } catch (x) {\n    console.error(\"FAILED: \" + name);\n    throw x;\n  }\n  console.log(\"passed: \" + name);\n}\n\nexport async function test_async(name, f) {\n  try {\n    await f();\n  } catch (x) {\n    console.error(\"FAILED: \" + name);\n    if (x.stack) {\n      console.error(x.stack);\n    }\n    process.exit(1);\n  }\n  console.log(\"passed: \" + name);\n}\n\nexport function remove_value(list, value) {\n  /* Removes the first occurance of value from the given list.\n     Returns a boolean indicating whether a value was removed. */\n  let idx = list.indexOf(value);\n  if (idx >= 0) {\n    list.splice(idx, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// // Changing the prototype!\n// Function.prototype.def_methods = function (source) {\n//   /* Define prototype methods, copied from the source object. */\n//   for (var key in source) {\n//     if (Object.prototype.hasOwnProperty.call(source, key)) {\n//       this.prototype[key] = source[key];\n//     }\n//   }\n//   return this;\n// };\n\nexport function equal(a, b) {\n  /* A structural equality function that looks for an equals method\n     on the first argument.  Handles arrays recursively, and otherwise\n     falls back to ===. */\n  if (typeof a === \"object\") {\n    if (typeof b === \"object\") {\n      if (a.equal) {\n        return a.equal(b);\n      }\n      if (a instanceof Array) {\n        if (!(b instanceof Array) || a.constructor !== b.constructor) {\n          return false;\n        }\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          if (!equal(a[i], b[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n  }\n  return a === b;\n}\n\nexport function compare(a, b) {\n  /* Returns \"a - b\" for comparison purposes. Does lexicographical\n  ordering for things that are instanceof Array after sorting by\n  length. Requires that arguments have same type. */\n  assert(typeof a === typeof b);\n  if (typeof a === \"object\") {\n    if (a.compare) {\n      return a.compare(b);\n    } else if (a instanceof Array) {\n      assert(b instanceof Array);\n      assert(a.constructor === b.constructor);\n      if (a.length !== b.length) {\n        return a.length - b.length;\n      }\n      for (let i = 0; i < a.length; i++) {\n        let c = compare(a[i], b[i]);\n        if (c !== 0) return c;\n      }\n      return 0;\n    } else {\n      throw new TypeError;\n    }\n  } else if (typeof a === \"number\" || typeof a === \"boolean\") {\n    return a - b;\n  } else if (typeof a === \"string\") {\n    return a.localeCompare(b);\n  } else if (typeof a === \"null\" || typeof a === \"undefined\") {\n    return 0;\n  } else {\n    throw new Error(\"Unexpected type \" + typeof a);\n  }\n}\n\nfunction escapeChar(c) {\n  /* Given a character, returns a string that can appear in a JavaScript string literal. */\n  switch (c) {\n  case \"\\0\": return \"\\\\0\";\n  case \"\\\"\": return \"\\\\\\\"\";\n  case \"\\\\\": return \"\\\\\\\\\";\n  case \"\\n\": return \"\\\\n\";\n  case \"\\r\": return \"\\\\r\";\n  case \"\\v\": return \"\\\\v\";\n  case \"\\t\": return \"\\\\t\";\n  case \"\\b\": return \"\\\\b\";\n  case \"\\f\": return \"\\\\f\";\n  }\n  var code = c.charCodeAt(0);\n  if (32 <= code && code < 127) {\n    return c;\n  } else if (code < 256) {\n    return \"\\\\x\" + (code < 0x10 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n  } else {\n    return \"\\\\u\" + (code < 0x1000 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n  }\n}\n\nexport function toString(o) {\n  /* Give a string representation that tries somewhat to be valid\n     JavaScript code.  This is somewhat like repr in Python. */\n\n  if (o instanceof Array && o.toString === Array.prototype.toString) {\n    return \"[\" + o.map(toString).join(\", \") + \"]\";\n  } else if (typeof o === \"object\") {\n    return o.toString();\n  } else if (typeof o === \"string\") {\n    let s = \"'\";\n    for (let i = 0; i < o.length; i++) {\n      s += escapeChar(o.charAt(i));\n    }\n    return s + \"'\";\n  } else {\n    return ''+o;\n  }\n}\n\nexport class SimpleType extends Array {\n  /* A Mathematica-like type where the \"head\" is the constructor. */\n  constructor() {\n    /* Extremely annoyingly, the Array constructor with one argument\n       means to construct an array of a particular size.  This object\n       must comply.  Use the static method make instead. */\n    if (arguments.length === 1) {\n      super(arguments[0]);\n    } else {\n      super(arguments.length);\n      for (let i = 0; i < arguments.length; i++) {\n        this[i] = arguments[i];\n      }\n    }\n  }\n  equal(b) {\n    assert(b.constructor === this.constructor);\n    if (this.length !== b.length)\n      return false;\n    for (let i = 0; i < this.length; i++) {\n      if (!equal(this[i], b[i]))\n        return false;\n    }\n    return true;\n  }\n  compare(b) {\n    assert(b.constructor === this.constructor);\n    if (this.length !== b.length)\n      return this.length - b.length;\n    for (let i = 0; i < this.length; i++) {\n      let c = compare(this[i], b[i]);\n      if (c !== 0) return c;\n    }\n    return 0;\n  }\n  toString() {\n    return this.constructor.name + \".make(\" + this.map(toString).join(\", \") + \")\";\n  }\n\n  static make(/*args*/) {\n    /* A sane constructor. */\n    let o = new this(arguments.length);\n    for (let i = 0; i < arguments.length; i++) {\n      o[i] = arguments[i];\n    }\n    return o;\n  }\n}\n\nexport function clamp(val, lo, hi) {\n  /* Clamps the value to the range [lo, hi]. */\n  return Math.max(lo, Math.min(hi, val));\n}\n\nexport function hex_to_rgb(h) {\n  /* Takes an 0xrrggbb integer and outputs a \"#rrggbb\" string */\n  let b = h & 0xFF;\n  h = h >>> 8;\n  let g = h & 0xFF;\n  h = h >>> 8;\n  let r = h & 0xFF;\n  function s(i) {\n    if (i < 16) {\n      return \"0\" + i.toString(16);\n    } else {\n      return i.toString(16);\n    }\n  }\n  return \"#\" + s(r) + s(g) + s(b);\n}\n","import {assert} from \"./util.mjs\";\n\nexport const Integers = {\n  zero: 0,\n  unit: 1,\n  add: (a, b) => a + b,\n  mul: (a, b) => a * b,\n  negate: a => -a\n};\n\nexport function gcd(a, b) {\n  /* Calculates the greatest common divisor of the two arguments. */\n  assert(a === (0|a));\n  assert(b === (0|b));\n  a = Math.abs(a);\n  b = Math.abs(b);\n  if (a < b) {\n    [a, b] = [b, a];\n  }\n  while (b !== 0) {\n    [a, b] = [b, a % b];\n  }\n  return a;\n}\n","// kq - a knockoff jquery\n\nexport default function Q(node) {\n  if (node instanceof Q) {\n    return node;\n  } else if (typeof node === \"string\") {\n    return Q.query(node);\n  } else if (!this || this === window) {\n    return new Q(node);\n  } else if (arguments.length === 0) {\n    this.length = 0;\n  } else if (node === null) {\n    this.length = 0;\n  } else if (node instanceof Element || node === window) {\n    this[0] = node;\n    this.length = 1;\n  } else if (node instanceof NodeList) {\n    this.length = node.length;\n    for (let i = 0; i < node.length; i++) {\n      this[i] = node[i];\n    }\n  } else if (node instanceof Array) {\n    this.length = 0;\n    for (let i = 0; i < node.length; i++) {\n      if (node[i] instanceof Q) {\n        for (let j = 0; j < node[i].length; j++) {\n          this[this.length++] = node[i][j];\n        }\n      } else {\n        this[this.length++] = node[i];\n      }\n    }\n  } else if (typeof node === \"function\") {\n    this[0] = window;\n    this.length = 1;\n    this.on('load', node);\n  } else {\n    throw new Error(\"Invalid argument to Q\");\n  }\n};\n\nQ.create = function (tagname, props) {\n  /* Takes the tagname (a string), optionally an object of properties (or null), and finally a list of things to append. */\n  let el = new Q(document.createElement(tagname));\n  let i = 1;\n  if (typeof props === \"object\" && !(props instanceof Q)) {\n    i++;\n    if (props) {\n      for (let key in props) {\n        el[0][key] = props[key];\n      }\n    }\n  }\n  for (; i < arguments.length; i++) {\n    el.append(arguments[i]);\n  }\n  return el;\n};\nQ.textNode = function (s) {\n  return new Q(document.createTextNode(s));\n};\nQ.withId = function (id) {\n  return new Q(document.getElementById(id));\n};\nQ.query = function (q) {\n  return new Q(document.querySelectorAll(q));\n};\nQ.prototype.query = function (q) {\n  var list = new Q();\n  var j = 0;\n  for (var i = 0; i < this.length; i++) {\n    this[i].querySelectorAll(q).forEach(e => {\n      list[j++] = e;\n    });\n  }\n  list.length = j;\n  return list;\n};\nQ.prototype.forEach = function (f) {\n  for (var i = 0; i < this.length; i++) {\n    f(new Q(this[i]), i);\n  }\n};\nQ.prototype.append = function (/*varargs*/) {\n  for (let i = 0; i < arguments.length; i++) {\n    let node = arguments[i];\n    if (node instanceof Q) {\n      node.appendTo(this);\n    } else if (node instanceof Element) {\n      this[0].appendChild(node);\n    } else {\n      this[0].appendChild(document.createTextNode('' + node));\n    }\n  }\n  return this;\n};\nQ.prototype.appendTo = function (node) {\n  if (node instanceof Q) {\n    node = node[0];\n  }\n  for (var i = 0; i < this.length; i++) {\n    node.appendChild(this[i]);\n  }\n  return this;\n};\nQ.prototype.remove = function () {\n  for (var i = 0; i < this.length; i++) {\n    if (this[i].parentNode !== null) {\n      this[i].parentNode.removeChild(this[i]);\n    }\n  }\n  return this;\n};\nQ.prototype.addClass = function (cls) {\n  for (var i = 0; i < this.length; i++) {\n    this[i].classList.add(cls);\n  }\n  return this;\n};\nQ.prototype.removeClass = function (cls) {\n  for (var i = 0; i < this.length; i++) {\n    this[i].classList.remove(cls);\n  }\n  return this;\n};\nQ.prototype.toggleClass = function (cls, /*opt*/toggle) {\n  for (var i = 0; i < this.length; i++) {\n    if (arguments.length >= 2) {\n      this[i].classList.toggle(cls, toggle);\n    } else {\n      this[i].classList.toggle(cls);\n    }\n  }\n  return this;\n};\nQ.prototype.on = function (event, handler, useCapture) {\n  var events = event.split(' ');\n  for (var j = 0; j < events.length; j++) {\n    if (events[j] !== '') {\n      for (var i = 0; i < this.length; i++) {\n        this[i].addEventListener(events[j], handler, !!useCapture);\n      }\n    }\n  }\n  return this;\n};\nQ.prototype.off = function (event, handler) {\n  var events = event.split(' ');\n  for (var j = 0; j < events.length; j++) {\n    if (events[j] !== '') {\n      for (var i = 0; i < this.length; i++) {\n        this[i].removeEventListener(events[j], handler);\n      }\n    }\n  }\n  return this;    \n};\nQ.prototype.empty = function () {\n  for (var i = 0; i < this.length; i++) {\n    var node = this[i];\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n  }\n  return this;\n};\nQ.prototype.attr = function (k, /*opt*/v) {\n  if (arguments.length === 1) {\n    return this[0].getAttribute(k);\n  } else {\n    for (var i = 0; i < this.length; i++) {\n      this[i].setAttribute(k, v);\n    }\n    return this;\n  }\n};\nQ.prototype.prop = function (k, /*opt*/v) {\n  if (arguments.length === 1) {\n    return this[0][k];\n  } else {\n    for (var i = 0; i < this.length; i++) {\n      this[i][k] = v;\n    }\n    return this;\n  }\n};\nQ.prototype.value = function (/*opt*/v) {\n  if (arguments.length === 0) {\n    return this[0].value;\n  } else {\n    for (var i = 0; i < this.length; i++) {\n      this[i].value = v;\n    }\n    return this;\n  }\n};\nQ.prototype.css = function (k, /*opt*/v) {\n  if (arguments.length === 1) {\n    return this[0].style[k];\n  } else {\n    for (var i = 0; i < this.length; i++) {\n      this[i].style[k] = v;\n    }\n    return this;\n  }\n};\n\nfunction tag(tagname) {\n  Q[tagname] = function () {\n    return Q.create(tagname, ...arguments);\n  };\n}\n\ntag('div'); tag('span');\ntag('p');\ntag('ol'); tag('ul'); tag('li');\ntag('sup');\ntag('a');\n","// Plain polynomials, stored as lists of coefficients.\n// For routines like GCD, assumes these are polynomials with integer coefficients.\n\nimport {assert, SimpleType} from \"./util.mjs\";\nimport {gcd} from \"./integers.mjs\";\nimport Q from \"./kq.mjs\";\n\nexport class Poly extends SimpleType {\n  copy() {\n    return this.slice();\n  }\n  normalize() {\n    /* Normalize the polynomial representation in place */\n    while (this.length > 0 && this[this.length - 1] === 0) {\n      this.pop();\n    }\n    return this;\n  }\n  degree() {\n    /* The degree of the polynomial.  The constant-zero polynomial has degree -1. */\n    this.normalize();\n    return this.length - 1;\n  }\n  is_zero() {\n    return this.length === 0;\n  }\n  is_unit() {\n    return this.length === 1 && this[0] === 1;\n  }\n  leading_coeff() {\n    if (this.length === 0) {\n      return 0;\n    } else {\n      return this[this.length - 1];\n    }\n  }\n  is_monic(allow_negative=false) {\n    if (this.length > 0) {\n      let c = this[this.length - 1];\n      if (allow_negative) {\n        c = Math.abs(c);\n      }\n      return c === 1;\n    } else {\n      return false;\n    }\n  }\n  min_exp() {\n    /* Returns the number of times x divides the polynomial.  If this===0, then returns Infinity. */\n    if (this.length === 0) {\n      return Infinity;\n    } else {\n      for (let i = 0; i < this.length; i++) {\n        if (this[i] !== 0) {\n          return i;\n        }\n      }\n      return assert(false);\n    }\n  }\n  mul_x(s) {\n    /* Multiplies by x^s.  Allowed to be negative. */\n    if (this.length === 0) {\n      return Poly.zero;\n    } else if (s >= 0) {\n      let p = this.slice();\n      for (let i = 0; i < s; i++) {\n        p.unshift(0);\n      }\n      return p;\n    } else {\n      let p = this.slice();\n      s = -s;\n      for (let i = 0; i < s; i++) {\n        let c = p.shift();\n        assert(c === 0);\n      }\n      return p;\n    }\n  }\n  add(p2) {\n    /* Adds this polynomial to p2. */\n    assert(p2 instanceof Poly);\n    let p1 = this;\n    if (p1.length < p2.length) {\n      [p1, p2] = [p2, p1];\n    }\n    let p = p1.slice();\n    for (let i = 0; i < p2.length; i++) {\n      p[i] += p2[i];\n    }\n    return p.normalize();\n  }\n  mul(p2) {\n    /* Multiply this polynomial by p2. Assumes both are normalized. */\n    assert(p2 instanceof Poly);\n    let p1 = this;\n    if (p1.length === 0 || p2.length === 0) {\n      return Poly.zero;\n    }\n    let p = new Poly(p1.length + p2.length - 1);\n    p.fill(0);\n    for (let i1 = 0; i1 < p1.length; i1++) {\n      for (let i2 = 0; i2 < p2.length; i2++) {\n        p[i1 + i2] += p1[i1] * p2[i2];\n      }\n    }\n    return p; // no need to normalize\n  }\n  scale(c) {\n    /* Gives the polynomial times the scalar c. */\n    assert(typeof c === \"number\");\n    if (c === 0) {\n      return Poly.zero;\n    }\n    return this.map(coeff => coeff * c);\n  }\n\n  content() {\n    /* The content of a polynomial is the GCD of its coefficients */\n    return this.reduce((g, c) => gcd(g, c), 0);\n  }\n\n  z_divisible(c) {\n    /* Checks whether the polynomial is divisible by the scalar c. */\n    assert(typeof c === \"number\" && c !== 0);\n    return this.every(coeff => coeff % c === 0);\n  }\n\n  gcd(p2) {\n    /* Compute the gcd of this and p2, two polynomials with integer coefficients. */\n    assert(p2 instanceof Poly);\n    let C1 = this.slice(),\n        C2 = p2.slice();\n    C1.forEach(c => assert(c === (0|c)));\n    C2.forEach(c => assert(c === (0|c)));\n\n    let cont_gcd = gcd(C1.content(), C2.content());\n\n    // denominators for C1 and C2\n    let d1 = 1;\n    let d2 = 1;\n\n    function normalize_and_swap() {\n      C1.normalize();\n      if (C1.length === 0) {\n        d1 = 1;\n      } else {\n        let q = C1.content();\n        q *= Math.sign(C1[C1.length - 1]);\n        for (let i = 0; i < C1.length; i++) {\n          C1[i] /= q;\n        }\n        d1 = C1[C1.length - 1];\n      }\n      C2.normalize();\n      if (C2.length === 0) {\n        d2 = 1;\n      } else {\n        let q = C2.content();\n        q *= Math.sign(C2[C2.length - 1]);\n        for (let i = 0; i < C2.length; i++) {\n          C2[i] /= q;\n        }\n        d2 = C2[C2.length - 1];\n      }\n      if (C1.length < C2.length) {\n        [C1,d1, C2,d2] = [C2,d2, C1,d1];\n      }\n      let d_gcd = gcd(d1, d2);\n      d1 /= d_gcd;\n      d2 /= d_gcd;\n    }\n\n    normalize_and_swap();\n\n    while (C2.length > 0) {\n      for (let i = 0; i < C1.length; i++) {\n        C1[i] *= d2;\n      }\n      let k = C1.length - C2.length;\n      for (let i = 0; i < C2.length; i++) {\n        C1[i + k] -= d1 * C2[i];\n      }\n      normalize_and_swap();\n    }\n\n    for (let i = 0; i < C1.length; i++) {\n      C1[i] = C1[i] * cont_gcd;\n    }\n\n    return C1;\n  }\n\n  divide(q) {\n    /* Divide by the polynomial q, returning the quotient. */\n    assert(q instanceof Poly);\n    assert(q.degree() >= 0);\n    if (q.degree() === 0) {\n      return this.map(c => c / q[0]);\n    }\n    let q_lead = q.leading_coeff();\n    let r = this;\n    let d = Poly.zero;\n    while (true) {\n      let i = r.degree() - q.degree();\n      if (i < 0) break;\n      let c = r.leading_coeff() / q_lead;\n      d = d.add(Poly.incl(c).mul_x(i));\n      r = r.add(q.scale(-c).mul_x(i));\n    }\n    // now this == q * d + r\n    //console.log(\"divided \" + this + \" by \" + q);\n    //console.log(\"  got \" + d + \" rem \" + r);\n    return d;\n  }\n\n  static incl(c) {\n    /* The natural inclusion from the base ring. */\n    return Poly.make(c);\n  }\n}\n\nPoly.zero = Poly.make();\nPoly.unit = Poly.make(1);\n","import {assert, SimpleType} from \"./util.mjs\";\nimport {gcd} from \"./integers.mjs\";\nimport {Poly} from \"./poly.mjs\";\nimport Q from \"./kq.mjs\";\n\n// A Laurent polynomial is a Laurent list of LTerms.\n\nexport class LTerm {\n  constructor(coeff, exp) {\n    this.coeff = coeff;\n    this.exp = exp;\n  }\n  equal(term2) {\n    assert(term2 instanceof LTerm);\n    return this.coeff === term2.coeff && this.exp === term2.exp;\n  }\n  static make(coeff, exp) {\n    assert(arguments.length === 2);\n    return new this(coeff, exp);\n  }\n  toString() {\n    return \"LTerm.make(\" + this.coeff + \", \" + this.exp + \")\";\n  }\n}\n\nexport class Laurent extends SimpleType {\n  copy() {\n    return this.slice(); // ok since terms are immutable\n  }\n  is_zero() {\n    return this.length === 0;\n  }\n  normalize() {\n    /* Destructively simplify the polynomial */\n    this.sort((t1, t2) => t1.exp - t2.exp);\n    let i = 0;\n    while (i < this.length) {\n      let t1 = this[i];\n      let sum = t1.coeff;\n      let j = i + 1;\n      while (j < this.length && this[j].exp === t1.exp) {\n        sum += this[j].coeff;\n        j++;\n      }\n      if (sum === 0) {\n        this.splice(i, j-i);\n      } else if (j > i + 1) {\n        this[i] = LTerm.make(sum, t1.exp);\n        if (j-i-1 > 0) {\n          this.splice(i+1, j-i-1);\n        }\n        i++;\n      } else {\n        i++;\n      }\n    }\n    return this;\n  }\n  toListString() {\n    /* Outputs an [exponent; coefficient...] list. */\n    this.normalize();\n    if (this.length === 0) {\n      return \"[0; 0]\";\n    }\n    let minexp = this[0].exp;\n    let coeffs = [];\n    this.forEach(term => {\n      coeffs[term.exp-minexp] = term.coeff;\n    });\n    for (let i = 0; i < coeffs.length; i++) {\n      if (coeffs[i] === void 0) {\n        coeffs[i] = 0;\n      }\n    }\n    return \"[\" + minexp + \"; \" + coeffs + \"]\";\n  }\n  toMathematica(variable=\"t\", exp_divisor=1) {\n    this.normalize();\n    if (this.length === 0) {\n      return \"0\";\n    }\n    let s = \"\";\n    function form_exp(exp) {\n      if (exp === 1) {\n        return \"\";\n      } else if (Math.floor(exp) === exp) {\n        return \"^\"+exp;\n      } else {\n        return \"^(\"+(exp*exp_divisor)+\"/\"+exp_divisor+\")\";\n      }\n    }\n    for (let i = this.length-1; i >= 0; i--) {\n      let term = this[i];\n      let exp = term.exp/exp_divisor;\n      if (term.coeff > 0) {\n        if (s.length !== 0) {\n          s += \" + \";\n        }\n        if (term.coeff === 1 && exp === 0) {\n          s += \"1\";\n        } else {\n          if (term.coeff !== 1) {\n            s += term.coeff;\n          }\n          if (exp !== 0) {\n            s += variable + form_exp(exp);\n          }\n        }\n      } else if (term.coeff === -1) {\n        if (s.length === 0) {\n          s += \"-\";\n        } else {\n          s += \" - \";\n        }\n        if (exp === 0) {\n          s += \"1\";\n        } else {\n          s += variable + form_exp(exp);\n        }\n      } else {\n        if (s.length === 0) {\n          s += term.coeff;\n        } else {\n          s += \" - \" + (-term.coeff);\n        }\n        if (exp !== 0) {\n          s += variable + form_exp(exp);\n        }\n      }\n    }\n    return s;\n  }\n\n  toDOM(variable=\"t\", exp_divisor=1) {\n    this.normalize();\n    if (this.length === 0) {\n      return \"0\";\n    }\n    let s = [];\n    function form_exp(exp) {\n      function with_neg(v) {\n        if (v < 0) {\n          return \"\\u2212\" + (-v);\n        } else {\n          return ''+v;\n        }\n      }\n      if (exp === 1) {\n        // \"\"\n      } else if (Math.floor(exp) === exp) {\n        s.push(Q.create(\"sup\", with_neg(exp)));\n      } else {\n        s.push(Q.create(\"sup\", with_neg(exp*exp_divisor)+\"/\"+exp_divisor));\n      }\n    }\n    function add_var() {\n      s.push(Q.create(\"var\", variable));\n    }\n    for (let i = this.length-1; i >= 0; i--) {\n      let term = this[i];\n      let exp = term.exp/exp_divisor;\n      if (term.coeff > 0) {\n        if (s.length !== 0) {\n          s.push(\" + \");\n        }\n        if (term.coeff === 1 && exp === 0) {\n          s.push(\"1\");\n        } else {\n          if (term.coeff !== 1) {\n            s.push(''+term.coeff);\n          }\n          if (exp !== 0) {\n            add_var();\n            form_exp(exp);\n          }\n        }\n      } else if (term.coeff === -1) {\n        if (s.length === 0) {\n          s.push(\"\\u2212\");\n        } else {\n          s.push(\" \\u2212 \");\n        }\n        if (exp === 0) {\n          s.push(\"1\");\n        } else {\n          add_var();\n          form_exp(exp);\n        }\n      } else {\n        if (s.length === 0) {\n          s.push('' + term.coeff);\n        } else {\n          s.push(\" \\u2212 \" + (-term.coeff));\n        }\n        if (exp !== 0) {\n          add_var();\n          form_exp(exp);\n        }\n      }\n    }\n    return Q.create(\"span\", null, ...s);\n  }\n\n\n  add(p2, c=1, exp_offset=0) {\n    /* assumes both polynomials are simplified. returns a simplified\n       polynomial. calculates this + c*p2*t^exp_offset. */\n    assert(p2 instanceof Laurent);\n    let p1 = this;\n    let p = Laurent.make();\n    let i1 = 0, i2 = 0;\n    while (i1 < p1.length && i2 < p2.length) {\n      let t1 = p1[i1], t2 = p2[i2];\n      if (t1.exp < t2.exp+exp_offset) {\n        p.push(t1);\n        i1++;\n      } else if (t1.exp > t2.exp+exp_offset) {\n        p.push(LTerm.make(c*t2.coeff, t2.exp+exp_offset));\n        i2++;\n      } else {\n        let sum = t1.coeff+c*t2.coeff;\n        if (sum !== 0) {\n          p.push(LTerm.make(sum, t1.exp));\n        }\n        i1++;\n        i2++;\n      }\n    }\n    for (; i1 < p1.length; i1++) {\n      p.push(p1[i1]);\n    }\n    for (; i2 < p2.length; i2++) {\n      let t2 = p2[i2];\n      p.push(LTerm.make(c*t2.coeff, t2.exp+exp_offset));\n    }\n    return p;\n  }\n\n  mul(p2) {\n    /* Assumes this and p2 are simplified. Returns this*p2, simplified.\n       Does the grade-school algorithm using each term of p2.*/\n    assert(p2 instanceof Laurent);\n    let p = Laurent.make();\n    p2.forEach(t => {\n      p = p.add(this, t.coeff, t.exp);\n    });\n    return p;\n  }\n  simple_mul(c=1, exp=0) {\n    /* Returns c*this*t^exp. */\n    assert(typeof c === \"number\" && typeof exp === \"number\");\n    if (c === 0) {\n      return Laurent.zero;\n    }\n    let p = Laurent.make();\n    this.forEach(t => {\n      p.push(LTerm.make(c*t.coeff, exp+t.exp));\n    });\n    return p;\n  }\n\n  negate() {\n    return this.simple_mul(-1);\n  }\n\n  to_poly(preserve_degree=false) {\n    /* Multiplies the Laurent polynomial so that the min degree is 0, returning a Poly. */\n    if (this.length === 0) {\n      return Poly.zero;\n    } else {\n      let minexp = this[0].exp;\n      if (preserve_degree) {\n        assert(minexp >= 0);\n        minexp = 0;\n      }\n      let coeffs = Poly.make();\n      this.forEach(term => {\n        coeffs[term.exp-minexp] = term.coeff;\n      });\n      for (let i = 0; i < coeffs.length; i++) {\n        if (coeffs[i] === void 0) {\n          coeffs[i] = 0;\n        }\n      }\n      return coeffs;\n    }\n  }\n\n  coeffs() {\n    if (this.length === 0) {\n      return [];\n    } else {\n      let minexp = this[0].exp;\n      let coeffs = [];\n      this.forEach(term => {\n        coeffs[term.exp-minexp] = term.coeff;\n      });\n      for (let i = 0; i < coeffs.length; i++) {\n        if (coeffs[i] === void 0) {\n          coeffs[i] = 0;\n        }\n      }\n      return coeffs;\n    }\n  }\n  static fromCoeffs(coeffs, offset=0) {\n    let p = Laurent.make();\n    for (let i = 0; i < coeffs.length; i++) {\n      if (coeffs[i] !== 0) {\n        p.push(LTerm.make(coeffs[i], i + offset));\n      }\n    }\n    return p;\n  }\n\n  minexp() {\n    if (this.length === 0) {\n      return 0; // or is it -Infinity? (0 is practical.)\n    } else {\n      return this[0].exp;\n    }\n  }\n\n  div_by_loop() {\n    /* Divides by -t^2-t^(-2), which is important for the Kauffman bracket. */\n\n    // divide by 1+t^4 and renormalize\n\n    if (this.length === 0) {\n      return Laurent.zero;\n    }\n\n    let coeffs = this.coeffs();\n    let minexp = this.minexp();\n    let q = Laurent.make();\n    let state = [0,0,0,0];\n    for (let i = 0; i < coeffs.length; i++) {\n      let a = coeffs[i] - state[3];\n      state.pop();\n      state.unshift(a);\n      if (a !== 0) {\n        q.push(LTerm.make(-a, i + minexp + 2));\n      }\n    }\n    assert(state.every(x => x === 0));\n    return q;\n  }\n\n  gcd(p2) {\n    /* Compute the gcd of two Laurent polynomials with integer coefficients */\n    assert(p2 instanceof Laurent);\n\n    return Laurent.fromCoeffs(this.to_poly().gcd(p2.to_poly()));\n  }\n\n  // Making this a NumberSystem\n  static add(a, b) {\n    return a.add(b);\n  }\n  static mul(a, b) {\n    return a.mul(b);\n  }\n  static negate(a) {\n    return a.simple_mul(-1, 0);\n  }\n  static incl(v) {\n    /* The natural inclusion of the base field. */\n    assert(typeof v === \"number\");\n    if (v === 0) {\n      return Laurent.zero;\n    } else {\n      return Laurent.make(LTerm.make(v, 0));\n    }\n  }\n  static is_zero(a) {\n    return a.is_zero();\n  }\n}\n\nLaurent.zero = Laurent.make();\nLaurent.unit = Laurent.make(LTerm.make(1,0));\nLaurent.t = Laurent.make(LTerm.make(1,1));\nLaurent.tinv = Laurent.make(LTerm.make(1,-1));\n","// Planar diagrams\n//\n// http://www.katlas.org/wiki/Planar_Diagrams\n// https://snappy.math.uic.edu/spherogram.html\n// https://bitbucket.org/t3m/spherogram/raw/tip/spherogram_src/links/doc.pdf\n\nimport {assert, SimpleType} from \"./util.mjs\";\n\nexport class PD extends SimpleType {\n  toMathematica() {\n    return \"PD[\" + this.map(x => x.toMathematica()).join(\", \") + \"]\";\n  }\n  toSnappy() {\n    /* Gives the unoriented PD (Xp and Xm degrade to X). */\n    let crossings = this.map(x => {\n      if (x instanceof P) {\n        throw new Error(\"SnapPy doesn't support P paths\");\n      } else {\n        return x.toSnappy();\n      }\n    });\n    return \"Link([\" + crossings.join(\", \") + \"])\";\n  }\n}\n\nexport class X extends SimpleType {\n  static make(a, b, c, d) {\n    /* Represents a crossing like\n       \n         c \\ / b\n            /\n         d / \\ a\n\n       where a, b, c, and d are edge ids.\n    */\n\n    assert(arguments.length === 4);\n    return super.make(a, b, c, d);\n  }\n  toMathematica() {\n    return \"X[\" + this.join(\",\") + \"]\";\n  }\n  toSnappy() {\n    return \"(\" + this.join(\",\") + \")\";\n  }\n}\n\nexport class P extends SimpleType {\n  static make(a, b) {\n    /* Represents a path between edge ids a and b. */\n    assert(arguments.length === 2);\n    return super.make(a, b);\n  }\n  toMathematica() {\n    return \"P[\" + this.join(\",\") + \"]\";\n  }\n}\n\nexport class Xp extends X {\n  /* Represents a right-handed oriented crossing like\n       \n       c ^ ^ b\n          /\n       d / \\ a\n\n     where a, b, c, and d are edge ids. */\n\n  toMathematica() {\n    return \"Xp[\" + this.join(\",\") + \"]\";\n  }\n}\n\nexport class Xm extends X {\n  /* Represents a left-handed oriented crossing like\n       \n       d ^ ^ c\n          \\\n       a / \\ b\n\n     where a, b, c, and d are edge ids. */\n\n  toMathematica() {\n    return \"Xm[\" + this.join(\",\") + \"]\";\n  }\n}\n","import {assert} from \"./util.mjs\";\n\nexport class Point {\n  /* A point in two-dimensional Euclidean space. */\n  constructor (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  copy() {\n    return new Point(this.x, this.y);\n  }\n  toString() {\n    return \"new Point(\" + this.x + \", \" + this.y + \")\";\n  }\n\n  static equal(p1, p2) {\n    assert(p1 instanceof Point);\n    assert(p2 instanceof Point);\n    return p1.x === p2.x && p1.y === p2.y;\n  }\n\n  static similar(p1, p2, error=1e-10) {\n    /* Checks to see if the points are close to each other, within the\n       given error in each coordinate. */\n    assert(p1 instanceof Point);\n    assert(p2 instanceof Point);\n    return Math.abs(p1.x - p2.x) < error && Math.abs(p1.y - p2.y) < error;\n  }\n\n  static dist(p1, p2) {\n    /* Returns the distance between p1 and p2. */\n    assert(p1 instanceof Point);\n    assert(p2 instanceof Point);\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n    return Math.sqrt(dx*dx + dy*dy);\n  }\n\n  static norm_diff(p1, p2) {\n    /* Gives p1 - p2, normalized.  Returns a point even though it\n    should return a vector. Assumes the points are distinct. */\n    assert(p1 instanceof Point);\n    assert(p2 instanceof Point);\n    let dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n    let norm = Math.sqrt(dx*dx + dy*dy);\n    assert(norm > 0);\n    return new Point(dx/norm, dy/norm);\n  }\n}\n\nexport function calculate_angle(p0, p1, p2) {\n  /* Given segments (p0, p1) and (p0, p2), calculates the angle from p1 to p2. Returns an angle in (-pi,pi].*/\n  assert(p0 instanceof Point);\n  assert(p1 instanceof Point);\n  assert(p2 instanceof Point);\n  let vx = p1.x - p0.x,\n      vy = p1.y - p0.y,\n      wx = p2.x - p0.x,\n      wy = p2.y - p0.y;\n  // Put w into the orthogonal frame given by v\n  let vnorm = Math.sqrt(vx * vx + vy * vy);\n  let x = (vx*wx + vy*wy)/vnorm,\n      y = (-vy*wx + vx*wy)/vnorm;\n  return Math.atan2(y, x);\n}\n\nexport function pseudo_angle(p0, p1) {\n  /* Takes the ray from p0 through p1 and gives an \"angle\" with respect to the x-axis.  The \"angle\" is a monotonically increasing function of angle, and it lies in [0,1). */\n  // Modified from delaunator.js\n  let dx = p1.x - p0.x,\n      dy = p1.y - p0.y;\n  let p = dx / (Math.abs(dx) + Math.abs(dy));\n  return (dy >= 0 ? 1 - p : 3 + p) / 4;\n}\n\nexport function segment_contains_old(p1, p2, q, error=1e-10) {\n  /* Checks if the line segment (p1,p2) contains the point q. Returns a boolean. */\n  assert(!(Point.equal(p1, p2)));\n  assert(q instanceof Point);\n  let vx = p2.x - p1.x,\n      vy = p2.y - p1.y;\n  let wx = q.x - p1.x,\n      wy = q.y - p1.y;\n  let det = -vy*wx + vx*wy;\n  if (Math.abs(det) <= error) {\n    let t = (vx*wx + vy*wy) / (vx*vx + vy*vy);\n    return 0 <= t && t <= 1;\n  } else {\n    return false;\n  }\n}\n\nexport function segment_contains(p1, p2, q, error=1e-10) {\n  return segment_distance(p1, p2, q) <= error;\n}\n\nexport function segment_distance(p1, p2, q) {\n  /* Gives the distance from q to the line segment (p1, p2). */\n  assert(p1 instanceof Point);\n  assert(p2 instanceof Point);\n  assert(q instanceof Point);\n  if (Point.equal(p1, p2)) {\n    return Point.dist(p1, q);\n  }\n  let vx = p2.x - p1.x,\n      vy = p2.y - p1.y;\n  let wx = q.x - p1.x,\n      wy = q.y - p1.y;\n  let norm2 = vx*vx + vy*vy;\n  let t = (vx*wx + vy*wy)/norm2;\n  if (t < 0) {\n    return Point.dist(q, p1);\n  } else if (t > 1) {\n    return Point.dist(q, p2);\n  } else {\n    return Math.abs((-vy*wx + vx*wy)/Math.sqrt(norm2));\n  }\n}\n\nexport function segments_intersect_old(p1, p2, q1, q2) {\n  /* Checks if the line segments (p1,p2) and (q1,q2) intersect.\n     Returns the intersection point if they do intersect. */\n\n  // Thanks to Josh Horowitz, from his Knot Identification Tool\n  // https://github.com/joshuahhh/knot-identification-tool/\n  assert(p1 instanceof Point);\n  assert(p2 instanceof Point);\n  assert(q1 instanceof Point);\n  assert(q2 instanceof Point);\n\n  if (Point.equal(p1, q1) || Point.equal(p1, q2)) {\n    return p1;\n  } else if (Point.equal(p2, q1) || Point.equal(p2, q2)) {\n    return p2;\n  }\n\n  let det = (p1.x-p2.x)*(q1.y-q2.y)-(p1.y-p2.y)*(q1.x-q2.x);\n  if (det === 0) {\n    return null;\n  }\n  let xi = ((p1.x*p2.y-p1.y*p2.x)*(q1.x-q2.x)-(p1.x-p2.x)*(q1.x*q2.y-q1.y*q2.x))/det;\n  if (((p1.x <= xi && xi <= p2.x) || (p2.x <= xi && xi <= p1.x)) &&\n      ((q1.x <= xi && xi <= q2.x) || (q2.x <= xi && xi <= q1.x))) {\n    let yi = ((p1.x*p2.y-p1.y*p2.x)*(q1.y-q2.y)-(p1.y-p2.y)*(q1.x*q2.y-q1.y*q2.x))/det;\n    if (((p1.y <= yi && yi <= p2.y) || (p2.y <= yi && yi <= p1.y)) &&\n        ((q1.y <= yi && yi <= q2.y) || (q2.y <= yi && yi <= q1.y))) {\n      return new Point(xi, yi);\n    }\n  }\n  return null;\n}\n\nexport function lines_intersect(p1, p2, q1, q2) {\n  /* Checks if the lines given by the segments (p1,p2) and (q1,q2) intersect.\n     Returns the intersection point if they do intersect. */\n  assert(p1 instanceof Point);\n  assert(p2 instanceof Point);\n  assert(q1 instanceof Point);\n  assert(q2 instanceof Point);\n\n  let a = p1, b = p2,\n      c = q1, d = q2;\n\n  let det = (a.x-b.x)*(c.y-d.y) - (a.y-b.y)*(c.x-d.x);\n  if (det === 0) {\n    return null;\n  }\n  let d1 = a.x*b.y - a.y*b.x,\n      d2 = c.x*d.y - c.y*d.x;\n  let pt = new Point((d1*(c.x-d.x) - d2*(a.x-b.x)) / det,\n                     (d1*(c.y-d.y) - d2*(a.y-b.y)) / det);\n\n  return pt;\n}\n\nexport function segments_intersect(p1, p2, q1, q2, epsilon=1e-10) {\n  let pt = lines_intersect(p1, p2, q1, q2);\n  if (!pt || segment_distance(p1, p2, pt) > epsilon || segment_distance(q1, q2, pt) > epsilon) {\n    return null;\n  } else {\n    return pt;\n  }\n}\n\nexport function point_along(p1, p2, t) {\n  /* Given a line parameterized so that t=0 is p1 and t=1 is p2,\n     returns the point corresponding to t. */\n  assert(p1 instanceof Point);\n  assert(p2 instanceof Point);\n  return new Point((1-t)*p1.x + t*p2.x,\n                   (1-t)*p1.y + t*p2.y);\n}\n\nexport function* line_points(p1, p2) {\n  /* Bresenham line drawing algorithm. Returns a generator of Points\n     from p1 to p2.  The coordinates of these points are expected to\n     be integers. */\n  assert(p1 instanceof Point);\n  assert(p2 instanceof Point);\n  \n  var x1 = p1.x, y1 = p1.y,\n      x2 = p2.x, y2 = p2.y;\n  var dx = Math.abs(x2-x1),\n      sx = x1 < x2 ? 1 : -1,\n      dy = -Math.abs(y2-y1),\n      sy = y1 < y2 ? 1 : -1;\n  var err = dx+dy;\n\n  while (true) {\n    yield new Point(x1, y1);\n    if (x1 === x2 && y1 === y2) break;\n    var e2 = 2*err;\n    if (e2 >= dy) { err += dy; x1 += sx; }\n    if (e2 <= dx) { err += dx; y1 += sy; }\n  }\n}\n","import {assert, remove_value, toString, compare} from \"./util.mjs\";\nimport {Laurent, LTerm} from \"./laurent.mjs\";\nimport {Point, segments_intersect} from \"./geom2d.mjs\";\nimport {PD,P,X,Xp,Xm} from \"./pd.mjs\";\n\nexport class KnotGraph {\n  constructor(verts, edges, adjs) {\n    this.verts = verts; // [Point,...]\n    this.edges = edges; // [[vtx, vtx, comp],...]\n    this.adjs = adjs; // [[dart...],...] where dart 0 and 2 are under, 1 and 3 are over\n    // a dart is edgeid+1 or -edgeid-1 depending on which side the edge is\n  }\n\n  copy() {\n    return new KnotGraph(\n      this.verts.map(pt => pt.copy()),\n      this.edges.map(edge => edge.slice()),\n      this.adjs.map(list => list.slice())\n    );\n  }\n  \n  ensure_orientation() {\n    /* Goes through edges and makes sure they are oriented so that\n       [dart_start, dart_end] are the two vertices. The first edge in\n       the edge list determines the orientation if there is a\n       discrepancy. */\n    let seen_darts = new Set();\n    this.edges.forEach((edge, eid) => {\n      if (seen_darts.has(eid+1) || seen_darts.has(-eid-1)) {\n        return;\n      }\n      let dart = eid + 1;\n      let d = dart;\n      do {\n        seen_darts.add(d);\n        seen_darts.add(-d);\n        let curr_edge = this.dart_edge(d);\n        if (this.dart_start(d) !== curr_edge[0]) {\n          d = -d;\n\n          // swap vertices on edge\n          [curr_edge[0], curr_edge[1]] = [curr_edge[1], curr_edge[0]];\n\n          // swap darts in adj\n          let adj, idx;\n          adj = this.adjs[curr_edge[0]];\n          idx = adj.indexOf(-d);\n          assert(idx >= 0);\n          adj[idx] = d;\n          \n          adj = this.adjs[curr_edge[1]];\n          idx = adj.indexOf(d);\n          assert(idx >= 0);\n          adj[idx] = -d;\n\n          assert(this.dart_start(d) === curr_edge[0]);\n        }\n        d = this.through_dart(d);\n      } while (d !== dart);\n    });\n    //console.log(\"seen darts \" + seen_darts.size);\n    //console.log(\"edges \" + this.edges.length);\n  }\n  \n  reverse_orientation(dart_id) {\n    /* Reverses the orientation of the entire component given by\n       dart_id.  Assumes the diagram is already oriented. */\n    let circuit = this.dart_circuit(dart_id);\n    circuit.forEach(dart => {\n      let edge = this.dart_edge(dart);\n      // edge[0] is dart_start, by assumption\n      \n      // swap vertices on edge\n      [edge[0], edge[1]] = [edge[1], edge[0]];\n\n      // swap darts in adj\n      let adj, idx;\n      adj = this.adjs[edge[1]];\n      idx = adj.indexOf(dart);\n      assert(idx >= 0);\n      adj[idx] = -dart;\n\n      adj = this.adjs[edge[0]];\n      idx = adj.indexOf(-dart);\n      assert(idx >= 0);\n      adj[idx] = dart;\n    });\n  }\n  \n  make_alternating() {\n    /* Changes crossings to make this into an alternating\n       diagram. Assumes the diagram is oriented.  Leaves an\n       already-alternating diagram alone. */\n    let seen_edges = [];\n    let to_see = [];\n    let visit_edges = () => {\n      while (to_see.length) {\n        let eid = to_see.pop();\n        if (!seen_edges[eid]) {\n          let sign = null;\n          this.dart_circuit(eid + 1).forEach(dart => {\n            seen_edges[Math.abs(dart) - 1] = true;\n            let vid = this.dart_start(dart);\n            let this_sign = this.adjs[vid].indexOf(dart) % 2 === 0;\n            if (this.adjs[vid].length === 4) {\n              this.adjs[vid].forEach(dart => to_see.push(Math.abs(dart) - 1));\n              if (sign === this_sign) {\n                this.adjs[vid].push(this.adjs[vid].shift()); // rotate crossing\n                this_sign = !this_sign;\n              }\n              sign = this_sign;\n            }\n          });\n        }\n      }\n    };\n    for (let i = 0; i < this.edges.length; i++) {\n      if (!seen_edges[i]) {\n        to_see.push(i);\n        visit_edges();\n      }\n    }\n  }\n\n  is_alternating() {\n    /* Returns whether this is an alternating diagram.  Assumes the diagram is oriented. */\n    let seen_edges = [];\n    for (let eid = 0; eid < this.edges.length; eid++) {\n      if (!seen_edges[eid]) {\n        let sign = null;\n        let circ = this.dart_circuit(eid + 1);\n        for (let di = 0; di < circ.length; di++) {\n          let dart = circ[di];\n          seen_edges[Math.abs(dart) - 1] = true;\n          let vid = this.dart_start(dart);\n          let this_sign = this.adjs[vid].indexOf(dart) % 2 === 0;\n          if (this.adjs[vid].length === 4) {\n            if (sign === this_sign) {\n              // Not alternating\n              return false;\n            }\n            sign = this_sign;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  bridge_number() {\n    /* Returns the bridge number (in the classical sense: the number\n       of arcs that are everywhere-over) of the diagram.  Assumes the\n       diagram is oriented. Split unknotted loops have bridge number 1. */\n    let seen_edges = [];\n    let bridges = 0;\n    for (let eid = 0; eid < this.edges.length; eid++) {\n      if (!seen_edges[eid]) {\n        let dart = eid + 1;\n        let circ = this.dart_circuit(eid + 1);\n        circ.forEach(d => {\n          seen_edges[Math.abs(d) - 1] = true;\n        });\n        if (circ.every(d => this.dart_order(d) === 2)) {\n          bridges++;\n        } else {\n          circ = circ.filter(d => this.dart_order(d) === 4);\n          let j = 0;\n          while (j < circ.length && this.dart_is_over(circ[j])) {\n            j++;\n          }\n          if (j === circ.length) {\n            // this was an unknot on top of the diagram\n            bridges++;\n            continue;\n          }\n          for (let i = 0; i < circ.length;) {\n            let k = (i + j) % circ.length;\n            assert(!this.dart_is_over(circ[k]));\n            let cr = 0;\n            while(true) {\n              i++;\n              k = (i + j) % circ.length;\n              if (!this.dart_is_over(circ[k])) {\n                break;\n              }\n              cr++;\n            }\n            if (cr > 0) {\n              bridges++;\n            }\n          }\n        }\n      }\n    }\n    return bridges;\n  }\n  \n  auto_color(max_colors) {\n    /* Assigns colors to the components in an arbitrary order */\n    assert(max_colors > 0);\n    let next_color = 0;\n    let seen = new Array(this.edges.length);\n    for (let eid = 0; eid < this.edges.length; eid++) {\n      if (!seen[eid]) {\n        let color = (next_color++) % max_colors;\n        this.dart_circuit(eid + 1).forEach(dart => {\n          let deid = Math.abs(dart) - 1;\n          seen[deid] = true;\n          this.edges[deid][2] = color + 1;\n        });\n      }\n    }\n  }\n  \n  delete_component(dart_id) {\n    /* Deletes the entire component containing the given dart. Assumes\n       the diagram is oriented.*/\n    let edge_ids = this.dart_circuit(dart_id).map(dart => Math.abs(dart) - 1);\n    // remove edges and vertices from the graph by setting them to null, then compact\n    edge_ids.forEach(eid => {\n      let edge = this.edges[eid];\n      remove_value(this.adjs[edge[0]], eid+1);\n      remove_value(this.adjs[edge[0]], -eid-1);\n      remove_value(this.adjs[edge[1]], eid+1);\n      remove_value(this.adjs[edge[1]], -eid-1);\n      this.edges[eid] = null;\n    });\n    this.compact();\n  }\n  \n  compact() {\n    /* The edge and vertex lists are allowed to have nulls.  Deletes\n       any degree-0 vertices, and renumbers everything so there are no\n       nulls. */\n    let newverts = [];\n    for (let i = 0; i < this.verts.length; i++) {\n      if (this.adjs[i] && this.adjs[i].length === 0) {\n        this.verts[i] = null;\n      } else if (this.verts[i] !== null) {\n        let new_vid = newverts.length;\n        newverts.push(this.verts[i]);\n        this.verts[i] = new_vid; // store forwarding pointer\n      }\n    }\n    let newedges = [];\n    for (let i = 0; i < this.edges.length; i++) {\n      let edge = this.edges[i];\n      if (edge !== null) {\n        let new_eid = newedges.length;\n        this.edges[i] = new_eid; // store forwarding pointer\n        newedges.push([this.verts[edge[0]], this.verts[edge[1]], edge[2]]);\n      }\n    }\n    let newadjs = [];\n    for (let i = 0; i < this.verts.length; i++) {\n      let adj = this.adjs[i];\n      if (this.verts[i] !== null) {\n        let adj2 = [];\n        adj.forEach(dart => {\n          let fwd = this.edges[Math.abs(dart)-1];\n          if (fwd !== null) {\n            adj2.push(Math.sign(dart) * (fwd + 1));\n          }\n        });\n        newadjs.push(adj2);\n      }\n    }\n    this.verts = newverts;\n    this.edges = newedges;\n    this.adjs = newadjs;\n  }\n\n  unsubdivide(vtx_i) {\n    /* Does not check if this operation will leave the diagram in a non-planar state. */\n    assert(this.adjs[vtx_i].length === 2);\n    let dart = Math.abs(this.adjs[vtx_i][0]);\n    if (this.dart_end(dart) !== vtx_i) {\n      dart = Math.abs(this.adjs[vtx_i][1]);\n    }\n    assert(this.dart_end(dart) === vtx_i);\n    let e0 = dart - 1,\n        e1 = this.through_dart(dart) - 1;\n    assert(e1 >= 0);\n    let edge0 = this.edges[e0],\n        edge1 = this.edges[e1];\n    let v2 = this.dart_end(this.through_dart(dart));\n\n    let idx2 = this.adjs[v2].indexOf(this.opp_dart(this.through_dart(dart)));\n    assert(idx2 >= 0);\n\n    edge0[1] = edge1[1];\n    this.adjs[v2][idx2] = this.opp_dart(dart);\n    this.verts[vtx_i] = null;\n    this.adjs[vtx_i] = null;\n    this.edges[e1] = null;\n  }\n\n  simplify_mesh(pixels=2) {\n    /* Simplifies the mesh, unsubdividing edges so long as it doesn't\n       move things more than 1 pixel. Need to run compact afterwards. */\n    let do_remove = true;\n    while (do_remove) {\n      do_remove = false;\n      next_vtx:\n      for (let i = 0; i < this.verts.length; i++) {\n        let pt = this.verts[i];\n        if (pt === null) {\n          continue next_vtx;\n        }\n        let adj = this.adjs[i];\n        if (adj.length === 2) {\n          // calculate length of altitude h of triangle given by vectors pt_0-pt and pt_1-pt.\n          let v0 = this.dart_end(adj[0]),\n              v1 = this.dart_end(adj[1]);\n          let pt_0 = this.verts[v0],\n              pt_1 = this.verts[v1];\n          let w0x = pt_0.x - pt.x,\n              w0y = pt_0.y - pt.y,\n              w1x = pt_1.x - pt.x,\n              w1y = pt_1.y - pt.y,\n              ux = pt_0.x - pt_1.x,\n              uy = pt_0.y - pt_1.y;\n          let cross = w0x*w1y - w1x*w0y;\n          let h = Math.abs(cross) / Math.sqrt(ux*ux + uy*uy);\n\n          if (h <= pixels) {\n            // Will the unsubdivided version run through anything?\n            for (let j = 0; j < this.edges.length; j++) {\n              if (j !== Math.abs(adj[0]) - 1 && j !== Math.abs(adj[1]) - 1) {\n                let edge = this.edges[j];\n                if (edge === null) {\n                  continue;\n                }\n                if (segments_intersect(this.verts[edge[0]], this.verts[edge[1]],\n                                       pt_0, pt_1)) {\n                  continue next_vtx;\n                }\n              }\n            }\n            this.unsubdivide(i);\n            this.do_remove = true;\n          }\n        }\n      }\n    }\n  }\n\n  dart_start(dart_id) {\n    /* Takes a dart id and returns a vertex id. */\n    return this.dart_edge(dart_id)[dart_id > 0 ? 0 : 1];\n  }\n  dart_end(dart_id) {\n    /* Takes a dart id and returns a vertex id. */\n    assert(typeof dart_id === \"number\");\n    return this.dart_edge(dart_id)[dart_id > 0 ? 1 : 0];\n  }\n  dart_edge(dart_id) {\n    /* Takes a dart id and returns its underlying edge object. */\n    assert(typeof dart_id === \"number\");\n    return this.edges[Math.abs(dart_id)-1];\n  }\n  dart_order(dart_id) {\n    /* Takes a dart id and returns the number of incident darts at its vertex. */\n    let adj = this.adjs[this.dart_start(dart_id)];\n    return adj.length;\n  }\n  dart_is_over(dart_id) {\n    /* Assuming the dart id is for a dart at a crossing, gives whether the dart is part of the over-strand. */\n    assert(typeof dart_id === \"number\");\n    let adj = this.adjs[this.dart_start(dart_id)];\n    assert(adj.length === 4);\n    let idx = adj.indexOf(dart_id);\n    assert(idx >= 0);\n    return (idx % 2) === 1;\n  }\n  next_dart(dart_id) {\n    /* Takes a dart id and returns the next dart in counter-clockwise\n       order about its vertex. */\n    assert(typeof dart_id === \"number\");\n    let adj = this.adjs[this.dart_start(dart_id)];\n    let idx = adj.indexOf(dart_id);\n    assert(idx >= 0);\n    return adj[(idx + 1) % adj.length];\n  }\n  prev_dart(dart_id) {\n    /* Takes a dart id and returns the previous dart in counter-clockwise\n       order about its vertex. */\n    assert(typeof dart_id === \"number\");\n    let adj = this.adjs[this.dart_start(dart_id)];\n    let idx = adj.indexOf(dart_id);\n    assert(idx >= 0);\n    return adj[(idx + adj.length - 1) % adj.length];\n  }\n  opp_dart(dart_id) {\n    /* Takes a dart id and returns the other dart on its edge. */\n    assert(typeof dart_id === \"number\");\n    assert(dart_id !== 0 && Math.abs(dart_id) <= this.edges.length);\n    return -dart_id;\n  }\n  dart_oriented(dart_id) {\n    /* Returns whether this dart is pointing in the orientation of its circuit. */\n    let edge = this.dart_edge(dart_id);\n    return this.dart_start(dart_id) === edge[0];\n  }\n  through_dart(dart_id) {\n    /* Takes a dart id and returns the next dart in a circuit. */\n    let d = this.opp_dart(dart_id);\n    switch (this.dart_order(d)) {\n    case 2:\n      return this.next_dart(d);\n    case 4:\n      return this.next_dart(this.next_dart(d));\n    default:\n      throw new Error(\"Unexpected dart order\");\n    }\n  }\n  dart_circuit(dart_id) {\n    /* Takes a dart id and returns the circuit of darts, using through_dart. */\n    let path = [];\n    let d = dart_id;\n    do {\n      path.push(d);\n      d = this.through_dart(d);\n    } while (d !== dart_id);\n    return path;\n  }\n\n  crossing_number() {\n    let num = 0;\n    this.adjs.forEach(a => {\n      if (a.length === 4) {\n        num++;\n      }\n    });\n    return num;\n  }\n\n  writhe() {\n    /* Gives the total writhe of the diagram. */\n    let wr = 0;\n    this.adjs.forEach((a, vi) => {\n      if (a.length === 4) {\n        if (this.dart_oriented(a[1]) === this.dart_oriented(a[2])) {\n          wr += 1;\n        } else {\n          wr -= 1;\n        }\n      }\n    });\n    return wr;\n  }\n\n  linking_matrix() {\n    /* Gives the linking numbers between different colored components\n       as a matrix.  The diagonal is the writhe of that colored\n       component. */\n    let matrix = new Map();\n    function ensure_component(c) {\n      if (!matrix.has(c)) {\n        matrix.set(c, new Map());\n        matrix.get(c).set(c, 0);\n      }\n    }\n    function inc(c1, c2, delta) {\n      let m1 = matrix.get(c1);\n      m1.set(c2, (m1.get(c2)||0) + delta);\n      let m2 = matrix.get(c2);\n      m2.set(c1, (m2.get(c1)||0) + delta);\n    }\n    this.adjs.forEach((a, vi) => {\n      if (a.length === 2) {\n        let c = this.dart_edge(a[0])[2];\n        ensure_component(c);\n      } else if (a.length === 4) {\n        // recall: a[0] is dart for undercrossing\n        //  a[2] \\ / a[1]\n        //        /\n        //  a[3] / \\ a[0]\n        let c1 = this.dart_edge(a[1])[2],\n            c2 = this.dart_edge(a[2])[2];\n        ensure_component(c1);\n        ensure_component(c2);\n        if (this.dart_oriented(a[1]) === this.dart_oriented(a[2])) {\n          // so the crossing is positive\n          inc(c1, c2, 1/2);\n        } else {\n          inc(c1, c2, -1/2);\n        }\n      }\n    });\n    return matrix;\n  }\n\n  num_components() {\n    // Assumes edges are properly oriented\n    let seen_darts = new Set();\n    let n = 0;\n    for (let edge_i = 0; edge_i < this.edges.length; edge_i++) {\n      if (seen_darts.has(edge_i)) {\n        continue;\n      }\n      n++;\n      this.dart_circuit(edge_i + 1).forEach(dart => {\n        seen_darts.add(dart);\n      });\n    }\n    return n;\n  }\n\n  seifert_circuit(dart) {\n    /* Gives the Seifert circuit through the dart. */\n    let circuit = [];\n    let d = dart;\n    do {\n      circuit.push(d);\n      d = this.opp_dart(d);\n      // the following works whether adj.length is 2 or 4\n      if (this.dart_oriented(d) === this.dart_oriented(this.next_dart(d))) {\n        d = this.prev_dart(d);\n      } else {\n        d = this.next_dart(d);\n      }\n    } while (d !== dart);\n    return circuit;\n  }\n\n  genus() {\n    /* The canonical Seifert genus of this particular diagram. For\n       split diagrams, it is the sum of the genera of each component. */\n\n    let seen_darts = new Set();\n\n    let component_faces = (start_dart) => {\n      let nfaces = 0;\n      let to_see = [start_dart];\n      while (to_see.length > 0) {\n        let dart = to_see.pop();\n        if (seen_darts.has(dart)) {\n          continue;\n        }\n        nfaces++;\n        this.seifert_circuit(dart).forEach(d => {\n          to_see.push(...this.adjs[this.dart_start(d)]);\n          seen_darts.add(d);\n          seen_darts.add(this.opp_dart(d));\n        });\n      }\n      return nfaces;\n    };\n\n    let b_0 = 0;\n    let nfaces = 0;\n    for (let edge_i = 0; edge_i < this.edges.length; edge_i++) {\n      if (!seen_darts.has(edge_i + 1)) {\n        b_0++;\n        nfaces += component_faces(edge_i + 1);\n      }\n    }\n    return b_0 - (nfaces - this.crossing_number() + this.num_components())/2;\n  }\n\n  seifert_form() {\n    /* Gives the Seifert linking form of the diagram with respect to\n       some basis.  This is represented as [matrix, matrix, ...] with\n       one matrix per connected component of the diagram, where\n       together these form a block diagonal matrix. It should be\n       understood that the full linking form has in additional c-1\n       extra 0's on the diagonal (where c is the number of diagram\n       components), since a Seifert surface should be connected. */\n\n    let seen_edges = new Array(this.edges.length); // contains corresp. circuit ids\n    seen_edges.fill(-1);\n    let next_circuit_id = 0;\n    function circuit_id(edge_id) {\n      if (seen_edges[edge_id] === -1) {\n        return (seen_edges[edge_id] = next_circuit_id++);\n      } else {\n        return seen_edges[edge_id];\n      }\n    }\n\n    let visit_component = (start_edge) => {\n\n      // the first part is constructing a Seifert surface for this component.\n      // the meaning of circuits and twists will be described after it is constructed\n\n      let to_see = [start_edge]; // [edge_id, ...]\n\n      let circuits = new Map();\n      let twists = [];\n\n      function twist_id(edge1, edge2, x) {\n        for (let i = 0; i < twists.length; i++) {\n          let tw = twists[i];\n          if (tw[1] === edge1 && tw[2] === edge2) {\n            assert(x === tw[3]);\n            return tw[0];\n          }\n        }\n        let id = twists.length;\n        twists.push([id, edge1, edge2, x]);\n        return id;\n      }\n\n      while (to_see.length > 0) {\n        let eid = to_see.pop();\n        if (seen_edges[eid] !== -1) {\n          continue;\n        }\n        let circ_id = circuit_id(eid);\n        let circuit = this.seifert_circuit(eid + 1);\n        circuit.forEach(d => {\n          assert(d > 0);\n          seen_edges[d - 1] = circ_id;\n        });\n        circuit = circuit.filter(d => this.dart_order(d) === 4);\n        let circuit_adj = [];\n        circuits.set(circ_id, circuit_adj);\n        circuit.forEach(d => {\n          let eid1 = d - 1;\n          let adj = this.adjs[this.dart_start(d)];\n          let i = adj.indexOf(d);\n          let eid2, x, front;\n          if (this.dart_oriented(this.next_dart(d))) {\n            eid2 = this.next_dart(d) - 1;\n            x = 1 - 2 * (i % 2);\n            front = false;\n          } else {\n            eid2 = this.prev_dart(d) - 1;\n            x = 2 * (i % 2) - 1;\n            front = true;\n          }\n          assert(eid2 >= 0);\n          to_see.push(eid2);\n          if (front) {\n            let tw = twist_id(eid1, eid2, x);\n            circuit_adj.push(tw+1);\n          } else {\n            let tw = twist_id(eid2, eid1, x);\n            circuit_adj.push(-tw-1);\n          }\n        });\n      }\n\n      // replace edge ids with the correct circuit ids\n      twists.forEach(twist => {\n        twist[1] = seen_edges[twist[1]];\n        twist[2] = seen_edges[twist[2]];\n      });\n\n      // Consider an oriented ribbon graph in upper half space that is\n      // sort-of-planar in the following way.  Each vertex is an\n      // oriented rectangular strip that is perpendicularly incident\n      // along the long side to the boundary plane, and along this\n      // side, edge strips meet it either in the front or the back\n      // with respect to its orientation.  Then, since this is a\n      // Seifert surface from Seifert's algorithm, edges have a half\n      // twist somewhere along their length; this means edges meet one\n      // vertex in the front and one vertex in the back, to preserve\n      // orientation.\n      //\n      // We represent this as follows.\n      //\n      // The vertices are stored in\n      //    circuits : circ_id => [dart, ...]\n      // where a dart is eid + 1 or -eid - 1 depending on whether the\n      // edge is incident to the front or the back of the vertex.  The\n      // orientation of the vertex is given by the convention in the\n      // following picture:\n      //\n      //  back   front\n      //       ^\n      //       |-- d4\n      //  d3 --|\n      //  d2 --|\n      //       |-- d1\n      //       |-- d0\n      //       |\n      //    vertex\n      //\n      // Edges are stored in\n      //    twists : list of [eid, circ_id1, circ_id2, x:{-1,1}]\n      // where the twist is in front of circ_id1 and behind circ_id2,\n      // and where x is the sign of the twist.\n      //\n      // What hasn't been explained is exactly why this is the result\n      // of Seifert's algorithm.  Here is what to imagine: we have\n      // \"cut\" each Seifert circuit by isotoping a small interval of\n      // the Seifert disk away from the plane of the diagram.  That\n      // is, each circuit represents an oriented rectangle with one\n      // edge embedded in the plane of the diagram, and each ribbon is\n      // attached somewhere along the length of this edge.\n      //\n      // (This is a reason why Seifert graphs are planar as abstract\n      // graphs.)\n\n\n      // Now we compute a basis for H_1, represented by the edges in cross_edges\n\n      if (0) {\n        circuits = new Map;\n        circuits.set(0, [-1, -2]);\n        circuits.set(1, [2, -3, 1, -4]);\n        circuits.set(2, [4, 3]);\n        twists = [[0, 1, 0, -1], [1, 1, 0, -1], [2, 2, 1, 1], [3, 2, 1, 1]];\n      }\n\n      let tree = new Map; // circuit_id -> (dart_id | null).  null means root\n      tree.set(twists[0][1], null);\n      let to_visit = twists.slice();\n      let cross_edges = [];\n      while (to_visit.length > 0) {\n        let twist;\n        for (let i = 0; i < to_visit.length; i++) {\n          twist = to_visit[i];\n          if (tree.has(twist[1]) || tree.has(twist[2])) {\n            to_visit.splice(i, 1);\n            break;\n          }\n        }\n        assert(twist);\n        if (tree.has(twist[1]) && tree.has(twist[2])) {\n          cross_edges.push(twist);\n        } else if (tree.has(twist[1])) {\n          tree.set(twist[2], -twist[0]-1);\n        } else {\n          tree.set(twist[1], twist[0]+1);\n        }\n      }\n\n      // Next is to compute the cycles corresponding to the cross_edge\n      // representations, and then to convert this into a form that is\n      // convenient for computing the Seifert pairing.\n\n      function find_twist(id) {\n        for (let i = 0; i < twists.length; i++) {\n          if (twists[i][0] === id) {\n            return twists[i];\n          }\n        }\n        return assert(false);\n      }\n\n      function cycle(cross_edge) {\n        // path is [[same_orientation, edge], ...] for the cycle\n        let path = [[true, cross_edge]];\n        let cid;\n        cid = cross_edge[1];\n        while (tree.get(cid) !== null) {\n          let dart = tree.get(cid);\n          let twist = find_twist(Math.abs(dart) - 1);\n          path.unshift([dart < 0, twist]);\n          cid = twist[1 + (dart > 0)];\n        }\n        cid = cross_edge[2];\n        while (tree.get(cid) !== null) {\n          let dart = tree.get(cid);\n          let twist = find_twist(Math.abs(dart) - 1);\n          path.push([dart > 0, twist]);\n          cid = twist[1 + (dart > 0)];\n        }\n        // remove backtracking from the tree part\n        while (path[0][1][0] === path[path.length-1][1][0]) {\n          path.pop();\n          path.shift();\n        }\n        // now all edge ids are distinct\n        return path;\n      }\n\n      //cross_edges.forEach(ce => console.log(toString(cycle(ce))));\n      \n      function make_vector(cycle) {\n        // the cycle is as in the output of cycle()\n        let edges = []; // list of [eid, x, oriented]\n        let verts = []; // list of [vid, from_idx, front, to_idx, front]\n        for (let i = 0; i < cycle.length; i++) {\n          let [ori1, edge1] = cycle[i],\n              [ori2, edge2] = cycle[(i+1) % cycle.length];\n          edges.push([edge1[0], edge1[3], ori1]);\n\n          let vtx = edge1[1 + ori1];\n          let adj = circuits.get(vtx);\n          let dart1 = ori1 ? -edge1[0]-1 : edge1[0]+1,\n              dart2 = ori2 ? edge2[0]+1 : -edge2[0]-1;\n          let from = adj.indexOf(dart1),\n              to = adj.indexOf(dart2);\n          assert(from !== -1 && to !== -1);\n          verts.push([vtx, from, dart1 > 0, to, dart2 > 0]);\n        }\n        return {edges:edges, verts:verts};\n      }\n\n      //cross_edges.forEach(ce => console.log(make_vector(cycle(ce))));\n\n      function linking(vect1, vect2) {\n        // vect2 is pushed off\n        // count linking of vect2 over vect1\n        let link = 0;\n        vect1.edges.forEach(edge1 => {\n          let [eid, x, ori1] = edge1;\n          vect2.edges.forEach(edge2 => {\n            if (eid === edge2[0]) {\n              let ori2 = edge2[2];\n              if (x > 0) {\n                link += 2 * (ori1 === ori2) - 1;\n              }\n            }\n          });\n        });\n        vect1.verts.forEach(vert1 => {\n          let [vtx, from1, from1_front, to1, to1_front] = vert1;\n          vect2.verts.forEach(vert2 => {\n            if (vtx === vert2[0]) {\n              let [_, from2, from2_front, to2, to2_front] = vert2;\n\n              let ori1 = 1;\n              if (from1 > to1) {\n                ori1 = -1;\n                [from1, from1_front, to1, to1_front] = [to1, to1_front, from1, from1_front];\n              }\n              let ori2 = 1;\n              if (from2 > to2) {\n                ori2 = -1;\n                [from2, from2_front, to2, to2_front] = [to2, to2_front, from2, from2_front];\n              }\n\n              if (from1_front && (from2 < from1 && from1 <= to2)) {\n                link += ori1 * ori2;\n              }\n              if (to1_front && (from2 < to1 && to1 <= to2)) {\n                link -= ori1 * ori2;\n              }\n            }\n          });\n        });\n        return link;\n      }\n\n      let vecs = cross_edges.map(ce => make_vector(cycle(ce)));\n\n      let matrix = vecs.map(v1 => vecs.map(v2 => linking(v1, v2)));\n      console.log(toString(matrix));\n\n      return matrix;\n    };\n\n\n    let matrices = [];\n    for (let edge_i = 0; edge_i < this.edges.length; edge_i++) {\n      if (this.dart_order(edge_i + 1) === 4 && seen_edges[edge_i] === -1) {\n        matrices.push(visit_component(edge_i));\n      }\n    }\n    // Will be missing trivial unknot diagram components\n    for (let edge_i = 0; edge_i < this.edges.length; edge_i++) {\n      if (this.dart_order(edge_i + 1) === 2 && seen_edges[edge_i] === -1) {\n        matrices.push([]);\n        this.dart_circuit(edge_i + 1).forEach(dart => {\n          seen_edges[Math.abs(dart) - 1] = true;\n        });\n      }\n    }\n    return matrices;\n  }\n\n  turaev() {\n    /* Returns {genus:g, plus:p, minus:m} where g is the Turaev genus\n       of the diagram and p and m are whether the diagram is\n       plus-adequate and minus-adequate, respectively. */\n\n    let seen_darts = new Set();\n\n    let b_0 = 0;\n    let n_faces = 0;\n    let plus = true, // still plus-adequate\n        minus = true; // still minus-adequate\n    for (let edge_i = 0; edge_i < this.edges.length; edge_i++) {\n      if (!seen_darts.has(edge_i + 1)) {\n        b_0++;\n\n        let to_see = [[edge_i + 1, false]]; // [[dart, is_black], ...]\n        while (to_see.length > 0) {\n          let [dart, is_black] = to_see.pop();\n          if (seen_darts.has(dart)) {\n            continue;\n          }\n          n_faces++;\n          // walk the Turaev face corresponding to the dart\n          let face_fringe = new Set();\n          let d = dart;\n          do {\n            if (face_fringe.has(d)) {\n              if (is_black) {\n                plus = false;\n              } else {\n                minus = false;\n              }\n            }\n\n            {\n              // Add adjacent darts to to_see, using checkerboard coloring\n              let color = is_black;\n              let adj_d = d;\n              do {\n                color = !color;\n                adj_d = this.next_dart(adj_d);\n                to_see.push([adj_d, color]);\n              } while (d !== adj_d);\n            }\n            seen_darts.add(d);\n            d = this.opp_dart(d);\n            let adj = this.adjs[this.dart_start(d)];\n            if (adj.length === 2) {\n              d = this.next_dart(d);\n            } else {\n              if ((adj.indexOf(d) % 2 === 0) === is_black) {\n                d = this.next_dart(d);\n              } else {\n                d = this.prev_dart(d);\n              }\n\n              adj.forEach(adj_d => {\n                if (d !== adj_d) {\n                  face_fringe.add(adj_d);\n                  face_fringe.add(this.opp_dart(adj_d));\n                }\n              });\n            }\n          } while (d !== dart);\n        }\n      }\n    }\n    return {genus: b_0 + (this.crossing_number() - n_faces)/2,\n            plus: plus,\n            minus: minus};\n  }\n\n  get_pd(oriented=false) {\n    /* Gets an unoriented/oriented PD object.\n\n       Chooses edge ids in ascending order of component. Makes sure a -> c is the orientation.\n       If oriented=true, then Xr/Xl are used to determine the orientation of b--d.\n    */\n    let dart_arc = new Map();\n    let next_arc_id = 1;\n    let pd = PD.make();\n    let edge_ids = this.edges.map((edge, i) => i);\n    edge_ids.sort((i1, i2) => this.edges[i1][2] - this.edges[i2][2]);\n    for (let ii = 0; ii < edge_ids.length; ii++) {\n      let i = edge_ids[ii];\n      if (dart_arc.has(i + 1)) {\n        continue;\n      }\n      let circuit = this.dart_circuit(i + 1);\n      if (circuit.every(d => this.dart_order(d) === 2)) {\n        // then this is a loop\n        let arc = next_arc_id++;\n        pd.push(P.make(arc, arc));\n        circuit.forEach(d => {\n          dart_arc.set(d, arc);\n          dart_arc.set(-d, arc);\n        });\n      } else {\n        let j = 0;\n        while (this.dart_order(circuit[j]) !== 4) {\n          j++;\n        }\n        circuit = circuit.slice(j).concat(circuit.slice(0, j));\n        // now the first dart is at a crossing (is order 4).\n        let arc_id = null;\n        circuit.forEach(dart => {\n          if (this.dart_order(dart) === 4) {\n            arc_id = next_arc_id++;\n          }\n          dart_arc.set(dart, arc_id);\n          dart_arc.set(-dart, arc_id);\n        });\n      }\n    }\n    this.adjs.forEach(adj => {\n      if (adj.length === 4) {\n        if (!this.dart_oriented(adj[2])) {\n          adj = adj.slice(2).concat(adj.slice(0, 2));\n        }\n        let arcs = adj.map(d => dart_arc.get(d));\n        if (!oriented) {\n          pd.push(X.make(...arcs));\n        } else {\n          if (this.dart_oriented(adj[1])) {\n            pd.push(Xp.make(...arcs));\n          } else {\n            pd.push(Xm.make(...arcs));\n          }\n        }\n      }\n    });\n    return pd;\n  }\n\n  get_dt() {\n    /* If this is not a knot, return null.  Otherwise, return a\n       Dowker-Thistlethwaite code for the knot. */\n    if (this.num_components() !== 1) {\n      return null;\n    }\n    let circuit = this.dart_circuit(1).filter(d => this.dart_order(d) === 4);\n    if (circuit.length === 0) {\n      return [];\n    }\n    let n = circuit.length;\n\n    let code_from = (k) => {\n      let dart_crossing = new Map();\n      circuit.forEach((d, i) => {\n        dart_crossing.set(d, (i+n-k)%n);\n      });\n      let get_crossing = (dart) => {\n        let i = dart_crossing.get(this.next_dart(dart));\n        if (i === void 0) {\n          i = dart_crossing.get(this.prev_dart(dart));\n        }\n        return i;\n      };\n      let code = [];\n      for (let i = 0; i < circuit.length; i += 2) {\n        let j = get_crossing(circuit[(i+k)%n]);\n        if (this.dart_is_over(circuit[(i+k)%n])) {\n          code.push(-j-1);\n        } else {\n          code.push(j+1);\n        }\n      }\n      if (code[0] < 0) {\n        for (let i = 0; i < code.length; i++) {\n          code[i] = -code[i];\n        }\n      }\n      return code;\n    };\n\n    let codes = [];\n    for (let k = 0; k < circuit.length; k++) {\n      codes.push(code_from(k));\n    }\n    circuit = this.dart_circuit(-1).filter(d => this.dart_order(d) === 4);\n    for (let k = 0; k < circuit.length; k++) {\n      codes.push(code_from(k));\n    }\n\n    codes.sort(compare);\n\n    return codes[0];\n  }\n\n  skeleton() {\n    let parts = [];\n    let loops = []; /* disconnected loops; array of component ids */\n    let seen_edges = new Set;\n\n    for (let teid = 0; teid < this.edges.length; teid++) {\n      if (seen_edges.has(teid)) {\n        continue;\n      }\n\n      let circuit = this.dart_circuit(teid + 1);\n\n      if (circuit.every(d => this.dart_order(d) === 2)) {\n        loops.push(this.edges[teid][2]);\n        circuit.forEach(d => seen_edges.add(Math.abs(d) - 1));\n        continue;\n      }\n\n      let next_arc_id = 1;\n      let edge_arcs = new Map; /* map from edge id to arc id for non-loops */\n      let arc_comps = new Map; /* map from arc ids to component ids */\n      let part_verts = new Set;\n\n      let to_visit = [teid];\n      while (to_visit.length > 0) {\n        let eid = to_visit.pop();\n        if (seen_edges.has(eid)) {\n          continue;\n        }\n\n        let comp = this.edges[eid][2];\n        let circuit = this.dart_circuit(eid + 1);\n\n        // Combine edges into arcs\n\n        let j = 0;\n        while (this.dart_order(circuit[j]) !== 4) {\n          j++;\n        }\n        circuit = circuit.slice(j).concat(circuit.slice(0, j));\n        // ^ now the first dart is at a crossing (is of order 4).\n        let arc_id = null;\n        circuit.forEach(dart => {\n          if (this.dart_order(dart) === 4) {\n            arc_id = next_arc_id++;\n            arc_comps.set(arc_id, comp);\n            // record that this vertex is in this part\n            let vid = this.dart_edge(dart)[0];\n            part_verts.add(vid);\n            // add other edges at vertex to to_visit\n            this.adjs[vid].forEach(d => {\n              let e = Math.abs(d) - 1;\n              if (!seen_edges.has(e)) {\n                to_visit.push(e);\n              }\n            });\n          }\n          edge_arcs.set(Math.abs(dart) - 1, arc_id);\n          seen_edges.add(Math.abs(dart) - 1);\n        });\n      }\n\n      // Construct vertex lists\n      let verts = [];\n      part_verts.forEach(vid => {\n        let adj = this.adjs[vid].map(d => {\n          let arc_id = edge_arcs.get(Math.abs(d) - 1);\n          if (d > 0) {\n            return arc_id;\n          } else {\n            return -arc_id;\n          }\n        });\n        for (let i = 0; i < adj.length; i++) {\n          if (adj[i] < 0 &&\n              (adj[i] === -adj[(i + 1) % adj.length]\n               || adj[i] === -adj[(i + adj.length - 1) % adj.length])) {\n            // Reidemeister I loop.\n            // Add in an extra degree-2 vertex so that the graph has no loop edges\n            let arc_id = -adj[i];\n            let arc_id2 = next_arc_id++;\n            verts.push([arc_id2, -arc_id]);\n            adj[i] = -arc_id2;\n            if (arc_comps.has(arc_id)) {\n              arc_comps.set(arc_id2, arc_comps.get(arc_id));\n            } else {\n              arc_comps.set(-arc_id2, arc_comps.get(-arc_id));\n            }\n          }\n        }\n        verts.push(adj);\n      });\n      parts.push({\n        // A list of dart lists\n        verts: verts,\n        // A description of how the vertex arose (\"\" is default)\n        vert_types: verts.map(v => \"\"),\n        // A list of vertices for the knot; these are lists of darts\n        knot: verts,\n        // A map from darts for the knot to components. Only includes darts that match the knot's orientation.\n        comps: arc_comps\n      });\n    }\n    return {\n      // A list components.  There is one loop per entry\n      loops: loops,\n      parts: parts\n    };\n  }\n\n  beautify() {\n    /* Re-embed using the Tutte embedding of a barycentric subdivision. */\n\n    function barycentric(skel) {\n      function face_darts(dart) {\n        let darts = [];\n        let curr_dart = dart;\n        face_loop:\n        while (true) {\n          for (let vid = 0; vid < skel.verts.length; vid++) {\n            let idx = skel.verts[vid].indexOf(-curr_dart);\n            if (idx !== -1) {\n              curr_dart = skel.verts[vid][(idx + skel.verts[vid].length - 1) % skel.verts[vid].length];\n              darts.push(curr_dart);\n              if (curr_dart === dart) {\n                break face_loop;\n              } else {\n                continue face_loop;\n              }\n            }\n          }\n          throw new Error;\n        }\n        return darts;\n      }\n      function face_dart(dart) {\n        // Get a representative dart for the face\n        return Math.min(...face_darts(dart));\n      }\n\n      var fresh_dart = 1;\n      var darts = new Map;\n      function vert_key(vid) {\n        return \"[v \" + vid + \"]\";\n      }\n      function edge_key(dart) {\n        return \"[e \" + Math.abs(dart) + \"]\";\n      }\n      function face_key(dart) {\n        return \"[f \" + face_dart(dart) + \"]\";\n      }\n      function dart_for(key) {\n        if (!darts.has(key)) {\n          darts.set(key, fresh_dart++);\n        }\n        return darts.get(key);\n      }\n\n      let dart_remap = new Map;\n      let dart_remap_over_edge = new Map;\n\n      let verts = [];\n      let vert_types = [];\n      // vertices\n      skel.verts.forEach((vert, vid) => {\n        let new_vert = [];\n        vert.forEach((dart, i) => {\n          new_vert.push(dart_for(vert_key(vid) + edge_key(dart)));\n          dart_remap.set(dart, dart_for(vert_key(vid) + edge_key(dart)));\n          new_vert.push(dart_for(vert_key(vid) + i + face_key(dart)));\n        });\n        verts.push(new_vert);\n        vert_types.push(skel.vert_types[vid] + \"v\");\n      });\n      // edges\n      skel.verts.forEach((vert, vid) => {\n        vert.forEach((dart, i) => {\n          if (dart < 0) return;\n          let new_vert = [];\n          new_vert.push(dart_for(edge_key(dart) + face_key(dart)));\n          new_vert.push(-dart_for(vert_key(vid) + edge_key(dart)));\n          dart_remap_over_edge.set(-dart, -dart_for(vert_key(vid) + edge_key(dart)));\n          for (let vid = 0; vid < skel.verts.length; vid++) {\n            let idx = skel.verts[vid].indexOf(-dart);\n            if (idx != -1) {\n              new_vert.push(dart_for(edge_key(dart) + face_key(-dart)));\n              new_vert.push(-dart_for(vert_key(vid) + edge_key(dart)));\n              dart_remap_over_edge.set(dart, -dart_for(vert_key(vid) + edge_key(dart)));\n              verts.push(new_vert);\n              vert_types.push(\"e\");\n              return;\n            }\n          }\n          throw new Error;\n        });\n      });\n      // faces\n      let seen_faces = new Set;\n      skel.verts.forEach(vert => {\n        vert.forEach(dart => {\n          let face = face_dart(dart);\n          if (seen_faces.has(face)) {\n            return;\n          }\n          seen_faces.add(face);\n          let new_vert = [];\n          face_darts(dart).forEach(dart => {\n            // `dart` ranges over darts in face `face`.\n            for (let vid = 0; vid < skel.verts.length; vid++) {\n              let i = skel.verts[vid].indexOf(dart);\n              if (i !== -1) {\n                new_vert.push(-dart_for(vert_key(vid) + i + face_key(face)));\n                break;\n              }\n            }\n            new_vert.push(-dart_for(edge_key(dart) + face_key(face)));\n          });\n          verts.push(new_vert);\n          vert_types.push(\"f\");\n        });\n      });\n\n      let new_knot = skel.knot.map(p => p.map(d => dart_remap.get(d)));\n      let new_comps = new Map;\n      skel.comps.forEach((comp, d) => {\n        let d1 = dart_remap.get(d);\n        let d2 = dart_remap_over_edge.get(d);\n        new_comps.set(d1, comp);\n        new_comps.set(d2, comp);\n        new_knot.push([-d1, d2]);\n      });\n\n      { // check that verts is well-formed\n        let darts = new Set;\n        verts.forEach(adj => adj.forEach(d => {\n          assert(!darts.has(d));\n          darts.add(d);\n        }));\n        darts.forEach(d => {\n          assert(darts.has(-d));\n        });\n      }\n\n      return {\n        verts: verts,\n        vert_types: vert_types,\n        knot: new_knot,\n        comps: new_comps\n      };\n    }\n\n    let skel = this.skeleton();\n    console.log(skel);\n\n    this.verts = [];\n    this.edges = [];\n    this.adjs = [];\n\n    let num_parts = skel.loops.length + skel.parts.length;\n    let cols = Math.ceil(Math.sqrt(num_parts));\n    let row = 0;\n    let col = 0;\n\n    // Draw the unknot parts\n    skel.loops.forEach(comp => {\n      let cx = 800 / cols * (col + 0.5);\n      let cy = 800 / cols * (row + 0.5);\n      let r = 0.8 * 800 / cols / 2;\n\n      const SUBDIV = 30;\n      let vids = [];\n      for (let i = 0; i < SUBDIV; i++) {\n        let vid = this.verts.length;\n        this.verts.push(new Point(cx + r * Math.cos(2 * Math.PI * i / SUBDIV),\n                                  cy - r * Math.sin(2 * Math.PI * i / SUBDIV)));\n        vids.push(vid);\n      }\n      let edges = [];\n      for (let i = 0; i < SUBDIV; i++) {\n        let eid = this.edges.length;\n        this.edges.push([vids[i], vids[(i + 1) % SUBDIV], comp]);\n        edges.push(eid);\n      }\n      for (let i = 0; i < SUBDIV; i++) {\n        this.adjs.push([edges[i] + 1,\n                        -edges[(i + SUBDIV - 1) % SUBDIV] - 1]);\n      }\n\n      col++;\n      if (col >= cols) {\n        col = 0;\n        row++;\n      }\n    });\n\n    // Draw the knotted parts\n    skel.parts.forEach(part => {\n      let cx = 800 / cols * (col + 0.5);\n      let cy = 800 / cols * (row + 0.5);\n      let r = 0.8 * 800 / cols / 2;\n\n      const FACE_VERT_TYPE = \"fv\";\n      //console.log(part);\n      part = barycentric(part);\n      //console.log(part);\n      part = barycentric(part);\n      console.log(part);\n      //const FACE_VERT_TYPE = \"fvv\";\n      //part = barycentric(barycentric(barycentric(part)));\n\n      // locate best outside face.\n      let outside = null;\n      let max_degree = 0;\n      part.verts.forEach((vert, vid) => {\n        if (part.vert_types[vid] == FACE_VERT_TYPE && max_degree < vert.length) {\n          max_degree = vert.length;\n          outside = vid;\n        }\n      });\n      console.log(\"best: \" + outside);\n\n      let vid_of_dart = new Map;\n      part.verts.forEach((vert, vid) => {\n        vert.forEach(dart => {\n          vid_of_dart.set(dart, vid);\n        });\n      });\n\n      function row_reduce(matrix) {\n        let rows = matrix.length,\n            cols = matrix[0].length;\n        let i = 0, j = 0; // current pivot\n        while (i < rows && j < cols) {\n          let besti = i;\n          for (let k = i + 1; k < rows; k++) {\n            if (Math.abs(matrix[k][j]) > Math.abs(matrix[besti][j])) {\n              besti = k;\n            }\n          }\n          if (besti !== i) {\n            [matrix[i], matrix[besti]] = [matrix[besti], matrix[i]];\n          }\n          if (matrix[i][j] === 0) {\n            j++;\n            continue;\n          }\n          let c = matrix[i][j];\n          matrix[i] = matrix[i].map(v => v / c);\n          for (let k = 0; k < rows; k++) {\n            if (k !== i) {\n              c = matrix[k][j];\n              matrix[k][j] = 0;\n              for (let l = j + 1; l < cols; l++) {\n                matrix[k][l] -= c * matrix[i][l];\n              }\n            }\n          }\n          i++;\n          j++;\n        }\n      }\n\n      let matrixx = [];\n      let matrixy = [];\n      let is_fixed = new Set;\n      part.verts[outside].forEach((dart, i) => {\n        let vid = vid_of_dart.get(-dart);\n        is_fixed.add(vid);\n        let rowx = new Array(part.verts.length+1).fill(0);\n        rowx[vid] = 1;\n        rowx[part.verts.length] = Math.cos(2 * Math.PI * i / max_degree);\n        let rowy = new Array(part.verts.length+1).fill(0);\n        rowy[vid] = 1;\n        rowy[part.verts.length] = Math.sin(2 * Math.PI * i / max_degree);\n        matrixx.push(rowx);\n        matrixy.push(rowy);\n      });\n\n      part.verts.forEach((vert, vid) => {\n        if (vid === outside || is_fixed.has(vid)) {\n          return;\n        }\n        let rowx = new Array(part.verts.length+1).fill(0);\n        vert.forEach(dart => {\n          let vid2 = vid_of_dart.get(-dart);\n          rowx[vid2] += 1;\n          rowx[vid] -= 1;\n        });\n        matrixx.push(rowx);\n        matrixy.push(rowx.slice());\n      });\n\n      //console.log(\"{\" + matrixx.map(row => \"{\" + row.join(\",\") + \"}\").join(\",\") + \"}\");\n      //console.log(\"{\" + matrixy.map(row => \"{\" + row.join(\",\") + \"}\").join(\",\") + \"}\");\n\n      row_reduce(matrixx);\n      row_reduce(matrixy);\n\n      function vid_point(vid) {\n        if (vid < outside) {\n          return new Point(matrixx[vid][part.verts.length], matrixy[vid][part.verts.length]);\n        } else if (vid === outside) {\n          throw new Error;\n        } else {\n          return new Point(matrixx[vid - 1][part.verts.length], matrixy[vid - 1][part.verts.length]);\n        }\n      }\n\n      var points = [];\n      part.knot.forEach(p => {\n        points.push(vid_point(vid_of_dart.get(p[0])));\n      });\n      let minx = 1e10, maxx = -1e10,\n          miny = 1e10, maxy = -1e10;\n      points.forEach(pt => {\n        minx = Math.min(minx, pt.x);\n        maxx = Math.max(maxx, pt.x);\n        miny = Math.min(miny, pt.y);\n        maxy = Math.max(maxy, pt.y);\n      });\n      points.forEach(pt => {\n        let x = pt.x - (minx + maxx)/2,\n            y = pt.y - (miny + maxy)/2;\n        let scale = Math.max(maxx - minx, maxy - miny)/2;\n        pt.x = cx + x/scale * r;\n        pt.y = cy + y/scale * r;\n      });\n\n      let vids = [];\n      points.forEach(pt => {\n        let vid = this.verts.length;\n        this.verts.push(pt);\n        vids.push(vid);\n      });\n      let knot_vid_of_dart = new Map;\n      part.knot.forEach((vert, vid) => {\n        vert.forEach(dart => {\n          knot_vid_of_dart.set(dart, vid);\n        });\n      });\n      let edges = new Map;\n      part.comps.forEach((comp, d) => {\n        let eid = this.edges.length;\n        edges.set(d, eid);\n        this.edges.push([\n          vids[knot_vid_of_dart.get(d)],\n          vids[knot_vid_of_dart.get(-d)],\n          comp\n        ]);\n      });\n      part.knot.forEach((adj, knot_vid) => {\n        this.adjs.push(adj.map(d => {\n          if (edges.has(d)) {\n            return edges.get(d) + 1;\n          } else {\n            return -1-edges.get(-d);\n          }\n        }));\n      });\n\n      col++;\n      if (col >= cols) {\n        col = 0;\n        row++;\n      }\n    });\n\n    console.log(this);\n\n\n  }\n}\n","// The Temperley--Lieb category\n\nimport {assert, SimpleType, equal, compare, toString} from \"./util.mjs\";\nimport {Laurent} from \"./laurent.mjs\";\n\nexport class TLPath {\n  /* A pair of edge ids (integers). */\n  constructor(a, b) {\n    if (a > b) {\n      [a, b] = [b, a];\n    }\n    this[0] = a;\n    this[1] = b;\n  }\n  equal(path2) {\n    assert(path2 instanceof TLPath);\n    return this[0] === path2[0] && this[1] === path2[1];\n  }\n  compare(path2) {\n    assert(path2 instanceof TLPath);\n    let d = this[0] - path2[0];\n    if (d !== 0) {\n      return d;\n    } else {\n      return this[1] - path2[1];\n    }\n  }\n  static make(a, b) {\n    assert(arguments.length === 2);\n    return new this(a, b);\n  }\n  toString() {\n    return \"TLPath.make(\" + this[0] + \", \" + this[1] + \")\";\n  }\n}\n\nexport class TLTerm {\n  /* A Laurent coefficient and a [TLPath,...] list */\n  constructor(coeff, paths) {\n    this.coeff = coeff;\n    this.paths = paths;\n  }\n  static make(coeff, paths) {\n    return new this(coeff, paths);\n  }\n  toString() {\n    return \"TLTerm.make(\" + this.coeff + \", \" + toString(this.paths) + \")\";\n  }\n  equal(term2) {\n    assert(term2 instanceof TLTerm);\n    return equal(this.coeff, term2.coeff) && equal(this.paths, term2.paths);\n  }\n/*  compare(term2) {\n    assert(term2 instanceof TLTerm);\n    if (this.coeff !\n  }*/\n  normalize() {\n    /* In-place normalization of the TLTerm. */\n    let coeff = this.coeff,\n        paths = this.paths;\n    let i = 0;\n    main_loop:\n    while (i < paths.length) {\n      let p1 = paths[i];\n      if (p1[0] === p1[1]) { // self-loop\n        coeff = coeff.mul(TL.loop);\n        paths.splice(i, 1);\n        continue main_loop;\n      }\n      let j = i + 1;\n      while (j < paths.length) {\n        let p2 = paths[j];\n        for (let k1 = 0; k1 < 2; k1++) {\n          for (let k2 = 0; k2 < 2; k2++) {\n            if (p1[k1] === p2[k2]) {\n              paths[i] = TLPath.make(p1[1-k1], p2[1-k2]);\n              paths.splice(j, 1);\n              continue main_loop;\n            }\n          }\n        }\n        j++;\n      }\n      i++;\n    }\n    this.coeff = coeff;\n\n    // now paths are simplified\n\n    paths.sort((p1, p2) => p1[0] - p2[0]); // this is lexicographic since all edge indices are different\n\n    return this;\n  }\n}\n\nexport class TL extends SimpleType {\n  // A list of TLTerms\n  copy() {\n    return this.slice(); // ok since normalization keeps the term \"the same\"\n  }\n  normalize() {\n    /* In-place normalization of the TL. */\n    this.forEach(term => term.normalize());\n    this.sort((term1, term2) => compare(term1.paths, term2.paths));\n\n    let i = 0;\n    while (i < this.length) {\n      let term = this[i];\n      let sum = term.coeff;\n      let j = i + 1;\n      while (j < this.length && compare(term.paths, this[j].paths) === 0) {\n        sum = sum.add(this[j].coeff);\n        j++;\n      }\n      if (sum.length === 0) {\n        this.splice(i, j-i);\n      } else {\n        term.coeff = sum;\n        if (j-i-1 > 0) {\n          this.splice(i+1, j-i-1);\n        }\n        i++;\n      }\n    }\n\n    return this;\n  }\n\n  add(tl2) {\n    assert(tl2 instanceof TL);\n    return this.concat(tl2).normalize();\n  }\n\n  mul(tl2) {\n    assert(tl2 instanceof TL);\n    let tl = TL.make();\n    this.forEach(term1 => {\n      tl2.forEach(term2 => {\n        tl.push(TLTerm.make(term1.coeff.mul(term2.coeff),\n                            term1.paths.concat(term2.paths)));\n      });\n    });\n    return tl.normalize();\n  }\n}\nTL.unit = TL.make(TLTerm.make(Laurent.unit, []));\nTL.loop = Laurent.fromCoeffs([-1,0,0,0,-1], -2);\n","// Knot invariant caches\n//\n// Since many invariants take some computational power to compute,\n// this is a system for asynchronously computing invariants and\n// memoizing the results.\n\nimport {assert, toString, remove_value} from \"./util.mjs\";\n\nlet invariant_caches = new WeakMap;\n\nlet invariant_handlers = {};\n\nlet running_mts = [];\n\nexport function get_invariant(name, diagram, /*args*/) {\n  /* Returns a promise.  The extra arguments should be toString-able.\n     Technically, diagram can be any object, but it ought to be a\n     KnotGraph or a PD. */\n\n  assert(name in invariant_handlers);\n\n  let args = Array.prototype.slice.call(arguments, 2);\n  let key = name + toString(args);\n\n  let cache = invariant_caches.get(diagram);\n  if (cache && cache[key]) {\n    return cache[key];\n  }\n  if (!cache) {\n    cache = {};\n    invariant_caches.set(diagram, cache);\n  }\n  let mt = {\n    _canceled: false,\n    cancel: () => { mt._canceled = true; },\n    next_turn: () => new Promise((resolve, reject) => {\n      if (mt._canceled) {\n        reject(\"canceled\");\n      } else {\n        setTimeout(resolve, 0);\n      }\n    })\n  };\n  running_mts.push(mt);\n                                \n  let promise = new Promise((resolve, reject) => {\n    setTimeout(async function () {\n      try {\n        let val = invariant_handlers[name](mt, diagram, ...args);\n        resolve(val);\n      } catch (x) {\n        reject(x);\n      } finally {\n        remove_value(running_mts, mt);\n      }\n    }, 0);\n  });\n  cache[key] = promise;\n\n  return promise;\n}\n\nexport function cancel_invariants() {\n  /* Cancel ongoing calculations. */\n  running_mts.slice().forEach(mt => mt.cancel());\n}\n\nexport function define_invariant(name, f) {\n  /* f is a function (mt, diagram, ...args) -> Promise, where mt is\n     the \"multitasking system\", which has two functions next_turn()\n     (which the function can await for doing cooperative multitasking)\n     and cancel().  */\n  assert(!invariant_handlers[name]);\n  invariant_handlers[name] = f;\n}\n","import {assert} from \"./util.mjs\";\nimport {Laurent, LTerm} from \"./laurent.mjs\";\nimport {eigenvalues} from \"./eigenvalues.mjs\";\n\nexport function det(NumberSystem, matrix) {\n  /* Computes the determinant of the given matrix, with entries in the\n     NumberSystem = {zero, unit, add, mul, negate, is_zero}.  A matrix is a list of\n     lists.  Performs cofactor expansion along the first row (matrix[0][...]). */\n\n  if (matrix.length === 0) {\n    return NumberSystem.unit;\n  }\n  assert(matrix.length === matrix[0].length); // only square matrices\n\n  if (matrix.length === 1) {\n    return matrix[0][0];\n  }\n\n  if (matrix.length === 2) {\n    return NumberSystem.add(\n      NumberSystem.mul(matrix[0][0], matrix[1][1]),\n      NumberSystem.negate(NumberSystem.mul(matrix[1][0], matrix[0][1])));\n  }\n\n  if (matrix.length === 3) {\n    return NumberSystem.add(\n      NumberSystem.add(\n        NumberSystem.add(\n          NumberSystem.mul(NumberSystem.mul(matrix[0][0], matrix[1][1]), matrix[2][2]),\n          NumberSystem.mul(NumberSystem.mul(matrix[0][1], matrix[1][2]), matrix[2][0])),\n        NumberSystem.mul(NumberSystem.mul(matrix[0][2], matrix[1][0]), matrix[2][1])),\n      NumberSystem.negate(\n        NumberSystem.add(\n          NumberSystem.add(\n            NumberSystem.mul(NumberSystem.mul(matrix[0][0], matrix[2][1]), matrix[1][2]),\n            NumberSystem.mul(NumberSystem.mul(matrix[0][1], matrix[2][2]), matrix[1][0])),\n          NumberSystem.mul(NumberSystem.mul(matrix[0][2], matrix[2][0]), matrix[1][1]))\n      ));\n  }\n\n  // Do cofactor expansion over the first row.\n  let val = NumberSystem.zero;\n  for (let j = 0; j < matrix[0].length; j++) {\n    let c = matrix[0][j];\n    if (NumberSystem.is_zero(c)) {\n      continue;\n    }\n    if (j % 2 === 1) {\n      c = NumberSystem.negate(c);\n    }\n    let sub_matrix = [];\n    for (let i = 1; i < matrix.length; i++) {\n      sub_matrix.push(matrix[i].slice(0, j).concat(matrix[i].slice(j+1)));\n    }\n    val = NumberSystem.add(val, NumberSystem.mul(det(NumberSystem, sub_matrix), c));\n  }\n  return val;\n}\n\nexport function signature(matrix, error=1e-14) {\n  // The matrix is assumed to be an n x n integer matrix.\n\n  if (matrix.length === 0) {\n    return 0;\n  }\n  assert(matrix.length === matrix[0].length);\n\n  let evals = eigenvalues(matrix);\n\n  let sig = 0;\n  eigenvalues(matrix).forEach(lam => {\n    if (lam - error > 0) {\n      sig++;\n    } else if (lam + error < 0) {\n      sig--;\n    }\n  });\n  return sig;\n}\n","// Jones polynomial\n\nimport {assert, remove_value} from \"./util.mjs\";\nimport {Laurent, LTerm} from \"./laurent.mjs\";\nimport {PD, X, Xp, Xm} from \"./pd.mjs\";\nimport {KnotGraph} from \"./knotgraph.mjs\";\nimport {TL, TLTerm, TLPath} from \"./tl.mjs\";\nimport {get_invariant, define_invariant} from \"./invariants.mjs\";\n\ndefine_invariant(\"kauffman_bracket\", async function (mt, pd) {\n  if (!(pd instanceof PD)) {\n    return await get_invariant(\"kauffman_bracket\", pd.get_pd());\n  }\n\n  if (pd.length === 0) {\n    return null;\n  }\n  pd = pd.slice();\n\n  let frontier = [];\n  let bracket = TL.unit;\n  while (pd.length > 0) {\n    await mt.next_turn();\n\n    // find \"best\" next entity, using the most-in-frontier heuristic\n    let best_count = -1;\n    let best_eid = null;\n    pd.forEach((entity, eid) => {\n      let count = 0;\n      entity.forEach(i => {\n        if (frontier.indexOf(i) !== -1) {\n          count++;\n        }\n      });\n      if (count > best_count) {\n        best_count = count;\n        best_eid = eid;\n      }\n    });\n    let entity = pd[best_eid];\n    pd.splice(best_eid, 1);\n    let tl = null;\n    if (entity.length === 2) {\n      let [a, b] = entity;\n      tl = new TL(new TLTerm(Laurent.unit, [new TLPath(a, b)]));\n    } else {\n      let [a, b, c, d] = entity;\n      tl = new TL(new TLTerm(Laurent.t, [new TLPath(a, b),\n                                         new TLPath(c, d)]),\n                  new TLTerm(Laurent.tinv, [new TLPath(a, d),\n                                            new TLPath(b, c)]));\n    }\n    bracket = bracket.mul(tl);\n\n    // update frontier\n    entity.forEach(i => {\n      if (!remove_value(frontier, i)) {\n        frontier.push(i);\n      }\n    });\n  }\n  assert(bracket.length <= 1);\n  if (bracket.length === 0) {\n    return Laurent.zero;\n  } else {\n    assert(bracket[0].paths.length === 0);\n    return bracket[0].coeff.div_by_loop();\n  }\n});\n\ndefine_invariant(\"jones_poly\", async function (mt, diagram) {\n  /* Computes the Jones polynomial from a KnotGraph (or an oriented\n     PD). Returns a polynomial in T=t^2, or null for the empty diagram. */\n\n  let wr;\n  if (diagram instanceof PD) {\n    wr = 0;\n    diagram.forEach(entity => {\n      if (entity.length === 4) {\n        if (entity.constructor === Xp) {\n          wr++;\n        } else if (entity.constructor === Xm) {\n          wr--;\n        } else {\n          throw new TypeError;\n        }\n      }\n    });\n  } else {\n    assert(diagram instanceof KnotGraph);\n    wr = diagram.writhe();\n  }\n\n  let kb = await get_invariant('kauffman_bracket', diagram);\n  if (kb === null) {\n    return null;\n  }\n\n  let normalized_kb = kb.simple_mul(Math.pow(-1, wr), -3*wr);\n  // The following polynomial is in T=t^2.\n  let jp = new Laurent();\n  for (let i = normalized_kb.length - 1; i >= 0; i--) {\n    let term = normalized_kb[i];\n    let new_exp = -term.exp/2;\n    assert(new_exp === Math.floor(new_exp));\n    jp.push(new LTerm(term.coeff, new_exp));\n  }\n  return jp;\n\n});\n","// Free group algebra\n\nimport {assert, SimpleType, compare} from \"./util.mjs\";\nimport {Laurent, LTerm} from \"./laurent.mjs\";\n\nexport class FGWord extends SimpleType {\n  /* A FGWord is gen,exp,gen,exp,... where the exponents are numbers\n     and the generators are tested by ===. */\n  normalize() {\n    /* Reduce the freegroup word.  Accepts FGWords inside the FGWord in place of generators,\n       which are spliced in. (In Mathematica-speak, this symbol is flattenable.)*/\n    let i = 0;\n    while (i < this.length) {\n      if (this[i] instanceof FGWord) {\n        let w = this[i];\n        let exp = this[i+1];\n        if (exp < 0) {\n          w = w.inverse();\n          exp = -exp;\n        }\n        this.splice(i, 2);\n        for (let k = 0; k < exp; k++) {\n          this.splice(i, 0, ...w);\n        }\n        i = Math.max(0, i - 2);\n        continue;\n      }\n      let exp = this[i+1];\n      let j = i+2;\n      while (j < this.length && this[i] === this[j]) {\n        exp += this[j+1];\n        j += 2;\n      }\n      if (exp === 0) {\n        this.splice(i, j-i);\n        i = Math.max(0, i - 2);\n      } else {\n        this[i+1] = exp;\n        if (j-i-2 > 0) {\n          this.splice(i+2, j-i-2);\n        }\n        i += 2;\n      }\n    }\n    assert(i === this.length);\n    return this;\n  }\n\n  normalize_conj(full_normalize=true) {\n    /* Reduce the word, allowing conjugation and inversion, putting it\n       into a normal form. Returns a new word.  If full_normalize is\n       true, then returns the lexicographically minimal word among all\n       conjugates. */\n    let w = this.slice();\n    while (true) {\n      w.normalize();\n      if (w.length > 2) {\n        if (w[0] === w[w.length-2]) {\n          // Can conjugate to move end to front and reduce length\n          w[1] += w[w.length-1];\n          w.length = w.length - 2;\n          continue;\n        }\n      }\n      break;\n    }\n    if (!full_normalize || w.length === 0) {\n      return w;\n    }\n    let shifts = [];\n    for (let i = 0; i < w.length; i += 2) {\n      let sw = w.slice(i).concat(w.slice(0, i));\n      shifts.push(sw);\n      shifts.push(sw.inverse());\n    }\n    shifts.sort(compare);\n    return shifts[0];\n  }\n\n  inverse() {\n    let w = FGWord.make();\n    for (let i = this.length-2; i >= 0; i -= 2) {\n      w.push(this[i], -this[i+1]);\n    }\n    return w;\n  }\n\n  fox_deriv(gen) {\n    /* Returns an FGA of the Fox derivative with respect to gen.\n       (Not used by alexander polynomial implementation.)*/\n    if (this.length === 0) {\n      return FGA.zero;\n    } else if (this.length === 2 && this[1] === 1) {\n      return gen === this[0] ? FGA.unit : FGA.zero;\n    } else if (this.length === 2 && this[1] === -1) {\n      if (gen === this[0]) {\n        return FGA.make([-1, FGWord.make(this[0], -1)]);\n      } else {\n        return FGA.zero;\n      }\n    } else {\n      let u = this.slice(0,2), v = this.slice(2);\n      if (v.length === 0) {\n        v.push(u[0], u[1]-Math.sign(u[1]));\n        u[1] = Math.sign(u[1]);\n      }\n      return u.fox_deriv(gen)\n        .add(FGA.make([1,u]).mul(v.fox_deriv(gen)));\n    }\n  }\n\n  substitute(g, val) {\n    /* If g is a function, for each generator for which g is true,\n       replace with val.  Otherwise, do the same by checking === with g. */\n    let w = this.slice();\n    for (let i = 0; i < this.length; i += 2) {\n      if ((g instanceof Function && g(w[i])) || g === w[i]) {\n        w[i] = val;\n      }\n    }\n    return w.normalize();\n  }\n}\n\nexport class FGA extends SimpleType {\n  /* A list of terms, which are [coeff,FGWord] pairs. */\n\n  static gen(g, exp=1, c=1) {\n    let x = FGA.make([c,FGWord.make(g, exp)]);\n    return x.normalize();\n  }\n\n  normalize() {\n    this.forEach(term => term[1].normalize());\n    this.sort((term1, term2) => compare(term1[1], term2[1]));\n\n    let i = 0;\n    while (i < this.length) {\n      let term = this[i];\n      let sum = term[0];\n      let j = i + 1;\n      while (j < this.length && compare(term[1], this[j][1]) === 0) {\n        sum += this[j][0];\n        j++;\n      }\n      if (sum.length === 0) {\n        this.splice(i, j-i);\n      } else {\n        term[0] = sum;\n        if (j-i-1 > 0) {\n          this.splice(i+1, j-i-1);\n        }\n        i++;\n      }\n    }\n\n    return this;\n  }\n\n  scale(c) {\n    assert(typeof c === \"number\");\n    if (c === 0) {\n      return FGA.zero;\n    }\n    let w = FGA.make();\n    this.forEach(term => {\n      w.push([term[0]*c, term[1]]);\n    });\n    return w;\n  }\n\n  add(w2) {\n    assert(w2 instanceof FGA);\n    return this.concat(w2).normalize();\n  }\n\n  mul(w2) {\n    assert(w2 instanceof FGA);\n    let w = FGA.make();\n    this.forEach(term1 => {\n      w2.forEach(term2 => {\n        w.push([term1[0] * term2[0],\n                term1[1].concat(term2[1])]);\n      });\n    });\n    return w.normalize();\n  }\n\n  substitute(g, val) {\n    /* Calls substitute for each term. */\n    return this.map(term => [term[0], term[1].substitute(g, val)]).normalize();\n  }\n\n  toLaurent() {\n    /* Assumes g |-> t is a homomorphism and gives the image. */\n    let p = Laurent.make();\n    this.forEach(term => {\n      let exp = 0;\n      for (let i = 0; i < term[1].length; i += 2) {\n        exp += term[1][i+1];\n      }\n      p.push(LTerm.make(term[0], exp));\n    });\n    return p.normalize();\n  }\n}\nFGA.zero = FGA.make();\nFGA.unit = FGA.make([1,FGWord.make()]);\n","// Alexander polynomials\n\nimport {assert, compare} from \"./util.mjs\";\nimport {Laurent, LTerm} from \"./laurent.mjs\";\nimport {Poly} from \"./poly.mjs\";\nimport {det} from \"./matrix.mjs\";\nimport {PD, P, Xp, Xm} from \"./pd.mjs\";\nimport {FGA, FGWord} from \"./fga.mjs\";\nimport {get_invariant, define_invariant} from \"./invariants.mjs\";\n\nexport function wirtinger_presentation(pd) {\n  /* Returns the wirtinger presentation from an oriented PD */\n  if (!(pd instanceof PD)) {\n    pd = pd.get_pd(true);\n  }\n  let gens = []; // names of generators\n  let rels = [];\n  pd.forEach(entity => {\n    entity.forEach(i => {\n      if (gens[i] === void 0) {\n        gens[i] = \"x\" + i;\n      }\n    });\n    if (entity instanceof P) {\n      let a = gens[entity[0]],\n          b = gens[entity[1]];\n      rels.push(FGWord.make(a, 1, b, -1));\n    } else if (entity instanceof Xp) {\n      let a = gens[entity[0]],\n          b = gens[entity[1]],\n          c = gens[entity[2]],\n          d = gens[entity[3]];\n      rels.push(FGWord.make(d, 1, b, -1));\n      rels.push(FGWord.make(b, 1, c, 1, d, -1, a, -1));\n    } else if (entity instanceof Xm) {\n      let a = gens[entity[0]],\n          b = gens[entity[1]],\n          c = gens[entity[2]],\n          d = gens[entity[3]];\n      rels.push(FGWord.make(d, 1, b, -1));\n      rels.push(FGWord.make(c, 1, d, 1, a, -1, b, -1));\n    } else {\n      throw new TypeError;\n    }\n  });\n\n  let removed_gens = new Set();\n  simplification_round:\n  while (true) {\n    //console.log(\"rels \" + toString(rels));\n    // Remove empty words\n    rels = rels.map(r => r.normalize_conj(false)).filter(word => word.length > 0);\n    // and duplicates\n    rels.sort(compare);\n    let i = 0;\n    while (i + 1 < rels.length) {\n      if (compare(rels[i], rels[i+1]) === 0) {\n        rels.splice(i+1,1);\n      } else {\n        i++;\n      }\n    }\n    //console.log(\"  -> \" + toString(rels));\n\n    // Look for a relation that gives a generator in terms of other generators\n    for (let i = 0; i < rels.length; i++) {\n      let rel = rels[i];\n      try_next_g:\n      for (let j = 0; j < rel.length; j += 2) {\n        let g = rel[j];\n        if (Math.abs(rel[j+1]) === 1) {\n          for (let k = 0; k < rel.length; k += 2) {\n            if (k !== j && rel[k] === g) {\n              continue try_next_g;\n            }\n          }\n          let w = rel.slice(j+2).concat(rel.slice(0,j));\n          if (rel[j+1] === 1) {\n            w = w.inverse();\n          }\n          //console.log(\"from \" + toString(rel) + \" got \" + g + \" is \" + toString(w));\n          removed_gens.add(g);\n          rels.splice(i, 1);\n          rels = rels.map(rel => rel.substitute(g, w));\n          continue simplification_round;\n        }\n      }\n    }\n    // Didn't find anything\n    break;\n  }\n\n  let gen_list = gens.filter(g => !removed_gens.has(g));\n  \n  return {gens: gen_list,\n          rels: rels};\n}\n\nexport function alexander_module(pres) {\n  /* Given a presentation {gens,rels} of a group with a homomorphism\n     to Z where each generator is sent to 1, computes a matrix for the\n     Alexander module. */\n\n  // A common approach is to use Fox derivatives, like so:\n  //   let matrix = pres.gens.map(g => pres.rels.map(rel => rel.fox_deriv(g).toLaurent()));\n  // However, an algorithmically more efficient method is to \"linearize\" the relations directly.\n  // This essentially means taking a relation, constructing its image in the chain group, giving\n  // a column of the matrix, rather than using derivations to compute each entry one at a time.\n\n  // matrix[i][j] is for generator i and relation j\n  let matrix = pres.gens.map(g => pres.rels.map(rel => Laurent.zero));\n\n  pres.rels.forEach((rel, j) => {\n    let ab = 0;\n    for (let k = 0; k < rel.length; k += 2) {\n      let i = pres.gens.indexOf(rel[k]);\n      let exp = Math.sign(rel[k+1]);\n      let times = Math.abs(rel[k+1]);\n      for (let n = 0; n < times; n++) {\n        let term;\n        if (exp > 0) {\n          term = Laurent.make(LTerm.make(1, ab));\n        } else {\n          term = Laurent.make(LTerm.make(-1, ab-1));\n        }\n        matrix[i][j] = matrix[i][j].add(term);\n        ab += exp;\n      }\n    }\n  });\n\n  \n  // This is not yet a presentation.  It is the matrix A in the chain complex\n  //   C_2 --A--> C_1 -----> C_0\n  // The group C_0 is Z[t,t^{-1}], and the map from C_1 is g |-> t-1.\n  // Thus, the kernel has the basis gi-g1 for i != 1.\n  //\n  // This means we can just remove a row and get a presentation matrix.\n  matrix.pop();\n\n  // representative generators pres.gens.slice(0, pres.gens.length-1)\n  return simplify_presentation_matrix(matrix);\n}\n\nfunction simplify_presentation_matrix(matrix) {\n  /* Given a presentation matrix of Laurent polynomials over Z,\n     attempt to sort of simplify it.  We can't eaxctly do Smith Normal\n     Form because Z[t,t^{-1}] is not a PID, but we can sure try. */\n\n  if (matrix.length === 0) {\n    return [];\n  }\n\n  // scale by t^n so that everything is a polynomial\n  let min_exp = Infinity;\n  matrix.forEach(row => row.forEach(entry => {\n    if (!entry.is_zero()) {\n      min_exp = Math.min(min_exp, entry.minexp());\n    }\n  }));\n  if (min_exp === Infinity) {\n    min_exp = 0;\n  }\n  let pmatrix = matrix.map(row => row.map(entry => entry.simple_mul(1, -min_exp).to_poly(true)));\n\n  function normalize_row(i) {\n    let min_exp = Infinity;\n    for (let j = 0; j < pmatrix[i].length; j++) {\n      let c = pmatrix[i][j];\n      min_exp = Math.min(min_exp, c.min_exp());\n    }\n    if (min_exp < Infinity) {\n      for (let j = 0; j < pmatrix[i].length; j++) {\n        pmatrix[i][j] = pmatrix[i][j].mul_x(-min_exp);\n      }\n    }\n  }\n\n  function normalize_col(j) {\n    let min_exp = Infinity;\n    for (let i = 0; i < pmatrix.length; i++) {\n      let c = pmatrix[i][j];\n      min_exp = Math.min(min_exp, c.min_exp());\n    }\n    if (min_exp < Infinity) {\n      for (let i = 0; i < pmatrix.length; i++) {\n        pmatrix[i][j] = pmatrix[i][j].mul_x(-min_exp);\n      }\n    }\n  }\n\n  function delete_col(j) {\n    for (let i = 0; i < pmatrix.length; i++) {\n      pmatrix[i].splice(j, 1);\n    }\n  }\n\n  function delete_col_if_zero(j) {\n    let all_zero = true;\n    for (let i = 0; i < pmatrix.length; i++) {\n      all_zero = all_zero && pmatrix[i][j].is_zero();\n    }\n    if (all_zero) {\n      delete_col(j);\n    }\n  }\n  \n  function swap_rows(i1, i2) {\n    if (i1 === i2) {\n      return;\n    }\n    [pmatrix[i1], pmatrix[i2]] = [pmatrix[i2], pmatrix[i1]];\n  }\n  function swap_cols(j1, j2) {\n    if (j1 === j2) {\n      return;\n    }\n    for (let i = 0; i < pmatrix.length; i++) {\n      [pmatrix[i][j1], pmatrix[i][j2]] = [pmatrix[i][j2], pmatrix[i][j1]];\n    }\n  }\n  function add_to_col(j2, j1, c, n) {\n    /* col[j2] += c * col[j1] * x^n */\n    for (let i = 0; i < pmatrix.length; i++) {\n      pmatrix[i][j2] = pmatrix[i][j2].add(pmatrix[i][j1].scale(c).mul_x(n));\n    }\n  }\n\n  for (let j = pmatrix[0].length-1; j >= 0; j--) {\n    delete_col_if_zero(j);\n  }\n  for (let i = 0; i < pmatrix.length; i++) {\n    normalize_row(i);\n  }\n  for (let j = 0; j < pmatrix[0].length; j++) {\n    normalize_col(j);\n  }\n\n  // Now for a modified version of Gaussian elimination (Z[t] not a PID)\n  \n  function gauss_right() {\n    if (pmatrix.length === 0) {\n      return false;\n    }\n    let changed = false;\n\n    let i = 0,\n        j = 0;\n    gauss_loop:\n    while (i < pmatrix.length && j < pmatrix[0].length) {\n      if (pmatrix[i][j].is_zero()) {\n        for (let j2 = j + 1; j2 < pmatrix[0].length; j2++) {\n          if (!pmatrix[i][j2].is_zero()) {\n            swap_cols(j, j2);\n            changed = true;\n            continue gauss_loop;\n          }\n        }\n        i++;\n        continue gauss_loop;\n      }\n      if (pmatrix[i][j].leading_coeff() < 0) {\n        for (let i2 = i; i2 < pmatrix.length; i2++) {\n          pmatrix[i2][j] = pmatrix[i2][j].scale(-1);\n        }\n      }\n      { // reduce from (i,j) rightward if possible\n        let pij = pmatrix[i][j];\n        let deg = pij.degree();\n        let j2 = j + 1;\n        while (j2 < pmatrix[0].length) {\n          let pij2 = pmatrix[i][j2];\n          let deg2 = pij2.degree();\n          if (deg <= deg2 && pij.leading_coeff() <= Math.abs(pij2.leading_coeff())) {\n            let div = pij2.leading_coeff() / pij.leading_coeff();\n            let idiv = Math.sign(div) * Math.floor(Math.abs(div));\n            add_to_col(j2, j, -idiv, deg2 - deg);\n            normalize_col(j2);\n            delete_col_if_zero(j2);\n            changed = true;\n          } else {\n            j2++;\n          }\n        }\n      }\n      { // look for polynomial of least degree with smallest leading coefficient\n        let best_j = j,\n            best_deg = pmatrix[i][j].degree(),\n            best_leading = pmatrix[i][j].leading_coeff();\n        for (let j2 = j + 1; j2 < pmatrix[0].length; j2++) {\n          let pij2 = pmatrix[i][j2];\n          if (!pij2.is_zero() && pij2.degree() <= best_deg && Math.abs(pij2.leading_coeff()) <= best_leading) {\n            best_j = j2;\n            best_deg = pij2.degree();\n            best_leading = Math.abs(pij2.leading_coeff());\n          }\n        }\n        if (best_j !== j) {\n          swap_cols(j, best_j);\n          changed = true;\n          continue gauss_loop;\n        }\n      }\n      { // check that eliminated everything\n        let eliminated = true;\n        for (let j2 = j + 1; j2 < pmatrix[0].length; j2++) {\n          eliminated = eliminated && pmatrix[i][j2].is_zero();\n        }\n        if (!eliminated) {\n          break gauss_loop;\n        }\n      }\n      i++;\n      j++;\n    }\n\n    return changed;\n  }\n\n  function eliminate_null_gens() {\n    let j = 0;\n    next_gen:\n    while (pmatrix.length > 0 && j < pmatrix[0].length) {\n      let idx = null;\n      for (let i = 0; i < pmatrix.length; i++) {\n        let pij = pmatrix[i][j];\n        if (!pij.is_zero()) {\n          if (idx !== null || pij.degree() !== 0 || Math.abs(pij[0]) != 1) {\n            j++;\n            continue next_gen;\n          } else {\n            idx = i;\n          }\n        }\n      }\n      assert(idx !== null);\n      delete_col(j);\n      pmatrix.splice(idx, 1);\n    }\n  }\n\n  // temporary transpose\n  function transpose() {\n    let rows = pmatrix.length,\n        cols = rows > 0 ? pmatrix[0].length : 0;\n    let tpmatrix = new Array(cols);\n    for (let i = 0; i < cols; i++) {\n      tpmatrix[i] = new Array(rows);\n      for (let j = 0; j < rows; j++) {\n        tpmatrix[i][j] = pmatrix[j][i];\n      }\n    }\n    pmatrix = tpmatrix;\n  }\n\n  // make a best-effort reduction\n  for (let max_attempts = 4; max_attempts > 0; max_attempts--) {\n    let changed = false;\n    changed = gauss_right() || changed;\n    if (pmatrix.length === 0) break;\n    eliminate_null_gens();\n    if (pmatrix.length === 0) break;\n    pmatrix.reverse().forEach(row => row.reverse()); // sort of makes do back-substitution\n    changed = gauss_right() || changed;\n    if (pmatrix.length === 0) break;\n    eliminate_null_gens();\n    if (pmatrix.length === 0) break;\n    let old_pmatrix = pmatrix;\n    transpose(); // makes do row reduction other way\n    changed = gauss_right() || changed;\n    if (pmatrix.length === 0) { pmatrix = old_pmatrix; break; }\n    pmatrix.reverse().forEach(row => row.reverse());\n    changed = gauss_right() || changed;\n    if (pmatrix.length === 0) { pmatrix = old_pmatrix; break; }\n    transpose(); // return to correct form!\n    eliminate_null_gens();\n    if (!changed || pmatrix.length === 0) {\n      break;\n    }\n  }\n\n  return pmatrix.map(row => row.map(entry => Laurent.fromCoeffs(entry)));\n}\n\nexport function alexander_polynomial(module, n=0) {\n  /* Computes the nth Alexander polynomial with the given module\n  presentation. A module is an m x k matrix, with m the number of\n  generators.  The 0th Alexander polynomial is the standard one.*/\n\n  // Need to get all k=m-n minors of matrix.module.  In particular, the\n  // determinants of all the k x k submatrices.  In more\n  // particular, the GCD of these determinants.\n\n  let k = module.length - n;\n  if (k <= 0) {\n    return Laurent.unit;\n  }\n\n  let gcd = Laurent.zero;\n\n  let cur_rows = [];\n  function minor_rows(next_i) {\n    if (cur_rows.length === k) {\n      do_minor_cols(0);\n    } else {\n      for (let i = next_i; i < module.length - (k - cur_rows.length - 1); i++) {\n        cur_rows.push(module[i]);\n        minor_rows(i + 1);\n        cur_rows.pop();\n      }\n    }\n  }\n  let minor = [];\n  for (let i = 0; i < k; i++) {\n    minor.push([]);\n  }\n  function do_minor_cols(next_j) {\n    if (minor[0].length === k) {\n      gcd = gcd.gcd(det(Laurent, minor));\n    } else {\n      for (let j = next_j; j < module[0].length - (k - minor[0].length - 1); j++) {\n        for (let i = 0; i < k; i++) {\n          minor[i].push(cur_rows[i][j]);\n        }\n        do_minor_cols(j + 1);\n        for (let i = 0; i < k; i++) {\n          minor[i].pop();\n        }\n      }\n    }\n  }\n\n  minor_rows(0);\n\n  let coeffs = gcd.coeffs();\n  if (coeffs[0] < 0) {\n    coeffs = coeffs.map(c => -c);\n  }\n\n  return Laurent.fromCoeffs(coeffs, 0);\n}\n\ndefine_invariant(\"wirtinger_presentation\", async function (mt, diagram) {\n  return wirtinger_presentation(diagram);\n});\ndefine_invariant(\"alexander_module\", async function (mt, diagram) {\n  let wp = await get_invariant(\"wirtinger_presentation\", diagram);\n  return alexander_module(wp);\n});\ndefine_invariant(\"alexander_poly\", async function (mt, diagram, n/*default=0*/) {\n  if (arguments.length === 2) {\n    return await get_invariant(\"alexander_poly\", diagram, 0);\n  }\n  let matrix = await get_invariant(\"alexander_module\", diagram);\n  await mt.next_turn(); // just to let other things happen. the next line probably ought to be broken up.\n  return alexander_polynomial(matrix, n);\n});\n","// Rational functions, as pairs of polynomials\n\nimport {assert, SimpleType} from \"./util.mjs\";\nimport {Poly} from \"./poly.mjs\";\nimport {Laurent, LTerm} from \"./laurent.mjs\";\n\nexport class RatFun {\n  constructor (p, q) {\n    assert(p instanceof Poly);\n    assert(q instanceof Poly);\n\n    if (p.is_zero()) {\n      this.p = Poly.zero;\n      this.q = Poly.unit;\n      return;\n    }\n    if (q.is_unit()) {\n      this.p = p;\n      this.q = Poly.unit;\n      return;\n    }\n\n    let d = p.gcd(q);\n    this.p = p.divide(d);\n    this.q = q.divide(d);\n\n    if (this.q.leading_coeff() < 0) {\n      this.p = this.p.scale(-1);\n      this.q = this.q.scale(-1);\n    }\n  }\n\n  toString() {\n    return \"new RatFun(\" + this.p + \", \" + this.q + \")\";\n  }\n\n  is_zero() {\n    return this.p.is_zero();\n  }\n\n  add(f2) {\n    assert(f2 instanceof RatFun);\n    return new RatFun(this.p.mul(f2.q).add(this.q.mul(f2.p)),\n                      this.q.mul(f2.q));\n  }\n\n  scale(c) {\n    return new RatFun(this.p.scale(c), this.q);\n  }\n\n  mul(f2) {\n    assert(f2 instanceof RatFun);\n    let h1 = new RatFun(this.p, f2.q),\n        h2 = new RatFun(f2.p, this.q);\n    return new RatFun(h1.p.mul(h2.p), h1.q.mul(h2.q));\n  }\n\n  div(f2) {\n    assert(f2 instanceof RatFun);\n    let h1 = new RatFun(this.p, f2.p),\n        h2 = new RatFun(f2.q, this.q);\n    return new RatFun(h1.p.mul(h2.p), h1.q.mul(h2.q));\n  }\n\n  recip() {\n    return new RatFun(this.q, this.p);\n  }\n\n  static incl(c) {\n    return RatFun.from_poly(Poly.incl(c));\n  }\n\n  static from_poly(p) {\n    assert(p instanceof Poly);\n    return new RatFun(p, Poly.unit);\n  }\n  static from_laurent(p) {\n    assert(p instanceof Laurent);\n    \n    if (p.minexp() < 0) {\n      return new RatFun(p.to_poly(),\n                        Poly.incl(1).mul_x(-p.minexp()));      \n    } else {\n      return RatFun.from_poly(p.to_poly(true));\n    }\n  }\n}\nRatFun.unit = RatFun.incl(1);\nRatFun.zero = RatFun.incl(0);\n","// Conway potential\n//\n// Uses the Seifert matrix to calculate it directly.\n\nimport {assert, compare} from \"./util.mjs\";\nimport {Laurent, LTerm} from \"./laurent.mjs\";\nimport {Poly} from \"./poly.mjs\";\nimport {RatFun} from \"./ratfun.mjs\";\nimport {det} from \"./matrix.mjs\";\nimport {get_invariant, define_invariant} from \"./invariants.mjs\";\n\nfunction ratfun_det(lmatrix) {\n  /* compute the determinant of a matrix of Laurent polynomials */\n  if (lmatrix.length == 0) {\n    return Laurent.unit;\n  }\n\n  //console.log(\"{\" + lmatrix.map(row => \"{\" + row.join(\", \") + \"}\").join(\", \") + \"}\");\n\n  let matrix = lmatrix.map(row => row.map(p => RatFun.from_laurent(p)));\n  let rows = matrix.length,\n      cols = matrix[0].length;\n  assert(rows === cols); // only square matrices\n\n  //console.log(\"{\" + matrix.map(row => \"{\" + row.join(\", \") + \"}\").join(\", \") + \"}\");\n\n  let det = RatFun.unit;\n\n  // proceed by row reduction\n  let i = 0,\n      j = 0;\n  while (i < rows && j < cols) {\n    if (matrix[i][j].is_zero()) {\n      for (let k = i + 1; k < rows; k++) {\n        if (!matrix[k][j].is_zero()) {\n          [matrix[i], matrix[k]] = [matrix[k], matrix[i]];\n          det = det.scale(-1);\n          break;\n        }\n      }\n      if (matrix[i][j].is_zero()) {\n        return Laurent.zero;\n        //j++;\n        //continue;\n      }\n    }\n    let c = matrix[i][j];\n    det = det.mul(c);\n    if (det.is_zero()) {\n      return Laurent.zero;\n    }\n    matrix[i] = matrix[i].map(v => v.div(c));\n    for (let k = i + 1; k < rows; k++) {\n      c = matrix[k][j];\n      matrix[k][j] = RatFun.zero;\n      for (let l = j + 1; l < cols; l++) {\n        matrix[k][l] = matrix[k][l].add(matrix[i][l].mul(c).scale(-1));\n      }\n    }\n    i++;\n    j++;\n  }\n  // verify denominator is of right form\n  for (let i = 0; i < det.q.length - 1; i++) {\n    assert(det.q[i] === 0);\n  }\n  assert(det.q.leading_coeff() === 1);\n  return Laurent.fromCoeffs(det.p).simple_mul(1, -det.q.degree());\n}\n\ndefine_invariant(\"conway_poly\", async function (mt, diagram) {\n  let matrices = diagram.seifert_form();\n  if (matrices.length !== 1) {\n    // the number of connected components is not 1\n    return Laurent.zero;\n  }\n  let A = matrices[0];\n  // calculate C = -tA+t^{-1}A^T\n  // (chose +/- convention to match Linkinfo's conway polynomials)\n  let C = [];\n  for (let i = 0; i < A.length; i++) {\n    C.push([]);\n    for (let j = 0; j < A.length; j++) {\n      C[i][j] = Laurent.add(Laurent.mul(Laurent.incl(-A[i][j]), Laurent.t),\n                            Laurent.mul(Laurent.incl(A[j][i]), Laurent.tinv));\n    }\n  }\n  // pre_poly is the normalized Alexander polynomial\n//  let pre_poly = det(Laurent, C);\n//  console.log(\"det\");\n//  console.log(ratfun_det(C));\n  let pre_poly = ratfun_det(C);\n  if (pre_poly.is_zero()) {\n    return Laurent.zero;\n  }\n  let z = Laurent.add(Laurent.t, Laurent.negate(Laurent.tinv));\n  let zpows = [];\n  let pow = Laurent.unit;\n  for (let i = 0; pow.minexp() >= pre_poly.minexp(); i++) {\n    zpows.push(pow);\n    pow = Laurent.mul(pow, z);\n  }\n  let conway = Laurent.zero;\n  for (let i = -pre_poly.minexp(); i >= 0; i--) {\n    if (pre_poly.is_zero()) {\n      // done\n      break;\n    }\n    if (-pre_poly.minexp() === i) {\n      let zpow = zpows[i];\n      let c = pre_poly[0].coeff / zpow[0].coeff;\n      conway = conway.add(Laurent.incl(c).simple_mul(1, i));\n      pre_poly = pre_poly.add(Laurent.incl(-c).mul(zpow));\n    }\n  }\n\n  return conway;\n});\n","/* The knot table.  As tables are loaded, this array is populated with\n * knot data.  The key is the knot name (accd to KnotInfo/LinkInfo) */\nconst table = new Map;\nself.knot_table = table;\n\n/* a object containing objects that describe how to load this part of\n * the table and whether it's loaded. */\nvar table_loaders = {};\n\n/* A list of files that have already been requested. */\nvar requested_files = [];\n\n/* A list of callbacks waiting on things being loaded */\nvar waiting = [];\n\nfunction mk_table_loader_key(components, crossing_number, property) {\n  return \"/\" + components + \"/\" + crossing_number + \"/\" + property;\n}\n\nfunction get_table_loader_entry(components, crossing_number, property) {\n  let key = mk_table_loader_key(components, crossing_number, property);\n  let entry = table_loaders[key];\n  if (!entry) {\n    entry = table_loaders[key] = {\n      file: null,\n      loaded: false\n    };\n  }\n  return entry;\n}\n\nself.provides_knot_data = function (file, components, crossing_numbers, properties) {\n  /* Declare a file as being able to provide some knot data. */\n  crossing_numbers.forEach(crossing_number => {\n    components.forEach(comps => {\n      properties.forEach(property => {\n        let entry = get_table_loader_entry(comps, crossing_number, property);\n        if (!entry.loaded && !entry.file) {\n          entry.file = file;\n        }\n      });\n    });\n  });\n};\n\nself.loaded_knot_data = function (components, crossing_numbers, properties) {\n  /* Record that some knot data has been loaded, to notify anyone who might be waiting for it. */\n  crossing_numbers.forEach(crossing_number => {\n    components.forEach(comps => {\n      properties.forEach(property => {\n        let entry = get_table_loader_entry(comps, crossing_number, property);\n        entry.loaded = true;\n      });\n    });\n  });\n  console.log(\"Loaded knot data crossings=%s; components=%s; properties=%s\", crossing_numbers.join(','), components.join(','), properties.join(','));\n\n  // Update keys for waiting things\n  var to_notify = [];\n  waiting.forEach(entry => {\n    entry.keys = entry.keys.filter(key => !table_loaders[key].loaded);\n    if (entry.keys.length === 0) {\n      to_notify.push(entry.callback);\n    }\n  });\n  waiting = waiting.filter(entry => entry.keys.length > 0);\n  // Notify things waiting on no more keys\n  to_notify.forEach(callback => callback());\n};\n\nself.add_knot_data = function (properties, data) {\n  /* Add data to the knot table.  (Does not notify anyone about the loaded data.  Use `loaded_knot_data`). */\n\n  for (let i = 0; i < data.length; i += 1 + properties.length) {\n    let name = data[i];\n    let entry = table.get(name);\n    if (!entry) {\n      entry = {name: name};\n      table.set(name, entry);\n    }\n    properties.forEach((property, j) => {\n      entry[property] = data[i + j + 1];\n    });\n  }\n};\n\nfunction needed_files(components, crossing_number, properties) {\n  /* Get a list of filenames that still need to be loaded. The `incomplete` key\n   refers to whether there are no data files that satisfy the request . */\n  let files = [];\n  let incomplete = false;\n  let missing_entries = [];\n  for (let c = 0; c <= crossing_number; c++) {\n    properties.forEach(property => {\n      let entry = get_table_loader_entry(components, c, property);\n      if (entry.file) {\n        if (!entry.loaded) {\n          if (!files.includes(entry.file)) {\n            files.push(entry.file);\n          }\n          missing_entries.push(mk_table_loader_key(components, c, property));\n        }\n      } else {\n        incomplete = true;\n      }\n    });\n  }\n  return {\n    files: files,\n    incomplete: incomplete,\n    missing_entries: missing_entries\n  };\n}\nself.needed_files = needed_files;\n\nfunction load_data(filename) {\n  if (!requested_files.includes(filename)) {\n    requested_files.push(filename);\n    let tag = document.createElement(\"script\");\n    tag.src = filename;\n    tag.type = \"text/javascript\";\n    tag.async = true;\n    document.getElementsByTagName('head')[0].appendChild(tag);\n  }\n}\n\nexport function get_knots(components, crossings, properties) {\n  /* Get list of all knots/links with at most the given number of crossings */\n\n  // First determine which files to load (if any)\n  let needed = needed_files(components, crossings, properties);\n  console.log(needed);\n\n  function _get_knots(resolve) {\n    let knots = [];\n    table.forEach(knot => {\n      if (knot.components === components && knot.crossing_number <= crossings) {\n        knots.push(knot);\n      }\n    });\n    resolve({\n      knots: knots,\n      incomplete: needed.incomplete\n    });\n  }\n\n  return new Promise((resolve, reject) => {\n    if (needed.files.length > 0) {\n      needed.files.forEach(filename => load_data(filename));\n      waiting.push({\n        callback: () => _get_knots(resolve),\n        keys: needed.missing_entries\n      });\n    } else {\n      _get_knots(resolve);\n    }\n  });\n}\n\nself.get_knots = get_knots;\n","import {get_invariant, define_invariant} from \"./invariants.mjs\";\nimport \"./jones.mjs\";\nimport \"./alexander.mjs\";\nimport {assert, equal} from \"./util.mjs\";\nimport * as knotdata from \"./knotdata.mjs\";\n\ndefine_invariant(\"identify_link\", async function (mt, diagram) {\n  let max_crossing = diagram.crossing_number();\n\n  let conway_poly = await get_invariant('conway_poly', diagram);\n  let conway_coeffs = [conway_poly.minexp()].concat(conway_poly.coeffs());\n  let conway_mirror = conway_coeffs.slice();\n  for (let i = 1; i < conway_mirror.length; i++) {\n    if ((conway_mirror[0] + i - 1) % 2 == 1) {\n      conway_mirror[i] = -conway_mirror[i];\n    }\n  }\n\n  let jones_poly = await get_invariant('jones_poly', diagram);\n  let jones_coeffs = jones_poly ? [jones_poly.minexp()].concat(jones_poly.coeffs()) : [0];\n  let jones_coeffs_rev = [-jones_coeffs.length + 2 - jones_coeffs[0]].concat(jones_coeffs.slice(1).reverse());\n\n  let table = await knotdata.get_knots(diagram.num_components(), max_crossing,\n                                       [\"conway\", \"jones\"]);\n\n  let options = table.knots.filter(o => {\n    let matches = equal(conway_coeffs, o.conway) && equal(jones_coeffs, o.jones);\n    if (!matches) {\n      matches = equal(conway_mirror, o.conway) && equal(jones_coeffs_rev, o.jones);\n    }\n    return matches;\n  });\n\n  let names = options.map(o => {\n    let obj = {name: o.name};\n    if (o.katlas) {\n      obj.katlas = \"http://katlas.math.toronto.edu/wiki/\" + o.katlas;\n    }\n    return obj;\n  });\n\n  return {\n    names: names,\n    incomplete: table.incomplete\n  };\n});\n","export const WIDTH = 800;\nexport const HEIGHT = 800;\nexport const PAINT_RADIUS = 1;\nexport const PAINT_GAP = 2;\nexport const ERASE_RADIUS = 5;\nexport const MIN_LINE_LENGTH = 2; // between mouse events\nexport const MAX_PPREV_DIST = 2*PAINT_RADIUS+1 + 2*PAINT_GAP; // for pencil-under\nexport const SPUR_LENGTH = 5; // the maximum-length spurs that will be auto-deleted in clean-up\nexport const ERROR_RADIUS = 6.5; // the radius of the red \"error circles\"\n//export const MAX_GAP_LENGTH = 70; // for under-crossings and gaps in lines\n\nexport const DIAGRAM_LINE_WIDTH = 3; // the width of the lines when drawing a diagram\nexport const CROSSING_GAP = 8; // the gap for drawing crossings\nexport const CROSSING_CHANGE_RADIUS = 10; // the radius of the disk shown when hovering over a crossing\n\n/* Colors for link components */\nexport const palette = [\n  0x000000,\n  0x0000ff,\n  0xff0000,\n  0x00cc00,\n  0x888888,\n  0x00aaee,\n  0x00ff00,\n  0xee00ee,\n  0xee8800,\n  0xffee00\n];\n","import {assert, hex_to_rgb, toString} from \"./util.mjs\";\nimport {KnotGraph} from \"./knotgraph.mjs\";\nimport {Point, segment_distance, point_along} from \"./geom2d.mjs\";\nimport {CROSSING_CHANGE_RADIUS, DIAGRAM_LINE_WIDTH, CROSSING_GAP, palette} from \"./constants.mjs\";\nimport {KnotRasterView} from \"./KnotRasterView.mjs\";\nimport {get_invariant} from \"./invariants.mjs\";\nimport {Laurent} from \"./laurent.mjs\";\nimport Q from \"./kq.mjs\";\nimport {signature} from \"./matrix.mjs\";\n\nlet global_tool_state = {\n  tool: \"crossing-change\"\n};\n\nlet default_pd_type = \"KnotTheory\";\n\nlet global_details_states = {\n  \"linking-matrix\": true,\n  \"seifert-matrix\": false,\n  \"alexander-module\": false\n};\nfunction attach_details_handler(name, $details) {\n  let initial_state = Boolean(global_details_states[name]);\n  $details.prop(\"open\", initial_state);\n  $details.on(\"toggle\", e => {\n    global_details_states[name] = $details.prop(\"open\");\n  });\n}\n\nexport class KnotDiagramView {\n  constructor(width, height, diagram) {\n    assert(width > 0);\n    assert(height > 0);\n    assert(diagram instanceof KnotGraph);\n    this.width = width;\n    this.height = height;\n    this.diagram = diagram;\n\n    this.c = new Point(0, 0);\n    this.zoom = 1;\n\n    this.mode_name = \"Diagrams\"; // constant\n  }\n\n  copy() {\n    let view = new KnotDiagramView(this.width, this.height, this.diagram.copy());\n    view.c = this.c.copy();\n    view.zoom = this.zoom;\n    return view;\n  }\n\n  mouse_to_pt(pt) {\n    assert(pt instanceof Point);\n    return new Point(this.zoom*(pt.x - this.c.x), this.zoom*(pt.y - this.c.y));\n  }\n\n  find_closest_crossing(pt) {\n    /* Returns a vertex id for the diagram, or null */\n    let diag = this.diagram;\n    let dist = CROSSING_CHANGE_RADIUS*this.zoom;\n    let closest = null;\n    diag.verts.forEach((vert, vid) => {\n      if (diag.adjs[vid].length === 4) {\n        let d = Point.dist(pt, vert);\n        if (d <= dist) {\n          dist = d;\n          closest = vid;\n        }\n      }\n    });\n    return closest;\n  }\n  \n  draw_crossing_disk(ctxt, cpt) {\n    let getX = (x) => {\n      return x/this.zoom+this.c.x;\n    };\n    let getY = (y) => {\n      return y/this.zoom+this.c.y;\n    };\n    ctxt.save();\n    ctxt.fillStyle = \"#0000ff\";\n    ctxt.globalAlpha = 0.2;\n    ctxt.beginPath();\n    ctxt.arc(getX(cpt.x)+0.5, getY(cpt.y)+0.5, CROSSING_CHANGE_RADIUS, 0, 2*Math.PI);\n    ctxt.fill();\n    ctxt.restore();\n  }\n\n  find_closest_circuit(pt) {\n    /* Returns a list of darts of the closest circuit to the given point. */\n    let diag = this.diagram;\n    let dist = 3*DIAGRAM_LINE_WIDTH*this.zoom;\n    let closest_eid = null;\n    diag.edges.forEach((edge, eid) => {\n      let d = segment_distance(diag.verts[edge[0]], diag.verts[edge[1]], pt);\n      if (d <= dist) {\n        dist = d;\n        closest_eid = eid;\n      }\n    });\n    if (closest_eid == null) {\n      return null;\n    }\n    return diag.dart_circuit(closest_eid+1);\n  }\n  highlight_circuit(ctxt, circuit) {\n    let getX = (x) => {\n      return x/this.zoom+this.c.x;\n    };\n    let getY = (y) => {\n      return y/this.zoom+this.c.y;\n    };\n\n    let diag = this.diagram;\n    let pts = circuit.map(dart => diag.verts[diag.dart_start(dart)]);\n    ctxt.save();\n    ctxt.strokeStyle = \"#0000ff\";\n    ctxt.globalAlpha = 0.2;\n    ctxt.lineWidth = 3*DIAGRAM_LINE_WIDTH;\n    ctxt.beginPath();\n    pts.forEach(cpt => {\n      ctxt.lineTo(getX(cpt.x)+0.5, getY(cpt.y)+0.5);\n    });\n    ctxt.closePath();\n    ctxt.stroke();\n    ctxt.restore();\n\n  }\n\n  mousedown(pt, e, undo_stack, ctxt) {\n    pt = this.mouse_to_pt(pt);\n    let tool = global_tool_state.tool;\n    if (tool === \"crossing-change\") {\n      let closest = this.find_closest_crossing(pt);\n      if (closest !== null) {\n        let view = this.copy();\n        let adj = view.diagram.adjs[closest];\n        adj.push(adj.shift());\n        undo_stack.push(view);\n        view.draw_crossing_disk(ctxt, view.diagram.verts[closest]);\n      }\n    } else if (tool === \"toggle-orientation\") {\n      let circuit = this.find_closest_circuit(pt);\n      if (circuit !== null) {\n        let view = this.copy();\n        view.diagram.reverse_orientation(circuit[0]);\n        undo_stack.push(view);\n        view.highlight_circuit(ctxt, circuit);\n      }\n    } else if (tool === \"delete-component\") {\n      let circuit = this.find_closest_circuit(pt);\n      if (circuit !== null) {\n        let view = this.copy();\n        view.diagram.delete_component(circuit[0]);\n        undo_stack.push(view);\n      }\n    } else if (tool.startsWith(\"set-color-\")) {\n      let color = +tool.slice(\"set-color-\".length);\n      let circuit = this.find_closest_circuit(pt);\n      if (circuit !== null) {\n        let view = this.copy();\n        circuit.forEach(dart => {\n          let edge = view.diagram.dart_edge(dart);\n          edge[2] = color;\n        });\n        undo_stack.push(view);\n        view.highlight_circuit(ctxt, circuit);\n      }\n    }\n  }\n  mousemove(pt, e, undo_stack, ctxt) {\n    pt = this.mouse_to_pt(pt);\n    let tool = global_tool_state.tool;\n    if (tool === \"crossing-change\") {\n      this.paint(ctxt);\n      let closest = this.find_closest_crossing(pt);\n      if (closest !== null) {\n        this.draw_crossing_disk(ctxt, this.diagram.verts[closest]);\n      }\n    } else if (tool === \"toggle-orientation\") {\n      this.paint(ctxt);\n      let circuit = this.find_closest_circuit(pt);\n      if (circuit !== null) {\n        this.highlight_circuit(ctxt, circuit);\n      }\n    } else if (tool === \"delete-component\") {\n      this.paint(ctxt);\n      let circuit = this.find_closest_circuit(pt);\n      if (circuit !== null) {\n        this.highlight_circuit(ctxt, circuit);\n      }\n    } else if (tool.startsWith(\"set-color-\")) {\n      this.paint(ctxt);\n      let circuit = this.find_closest_circuit(pt);\n      if (circuit !== null) {\n        this.highlight_circuit(ctxt, circuit);\n      }\n    }\n  }\n  mouseup(pt, e, undo_stack, ctxt) {\n    pt = this.mouse_to_pt(pt);\n    let tool = global_tool_state.tool;\n  }\n  mousewheel(pt, e, undo_stack, ctxt) {\n    let delta = Math.sign(e.deltaY);\n    let kpt = this.mouse_to_pt(pt);\n    this.zoom *= Math.pow(1.05, delta);\n    let zkpt = this.mouse_to_pt(pt);\n    this.c.x += (zkpt.x - kpt.x) / this.zoom;\n    this.c.y += (zkpt.y - kpt.y) / this.zoom;\n    this.paint(ctxt);\n  }\n  toolbox(undo_stack) {\n    let $div = this.$div = Q.div();\n\n    let diagram = this.diagram;\n\n    /* Modification tools */\n    Q.create(\"h2\").append(\"Modification tools\").appendTo($div);\n    let $tools = Q.div().appendTo($div);\n\n    let $crossing_change = Q.span(Q.span({className:\"icon24-crossing\"}))\n        .addClass(\"icon-button\")\n        .prop(\"data-tool\", \"crossing-change\")\n        .prop(\"title\", \"Change crossing type\")\n        .appendTo($tools);\n\n    let $toggle_orientation = Q.span(Q.span({className:\"icon24-two-arrows\"}))\n        .addClass(\"icon-button\")\n        .prop(\"data-tool\", \"toggle-orientation\")\n        .prop(\"title\", \"Toggle component orientation\")\n        .appendTo($tools);\n\n    let $eraser = Q.span(Q.span({className:\"icon24-trash\"}))\n        .addClass(\"icon-button\")\n        .prop(\"data-tool\", \"delete-component\")\n        .prop(\"title\", \"Delete component\")\n        .appendTo($tools);\n\n    $tools.append(Q.create(\"br\"));\n    palette.forEach((hex, i) => {\n      let $b = Q.span().addClass(\"icon-button\")\n          .prop(\"data-tool\", \"set-color-\" + (i+1))\n          .prop(\"title\", \"Recolor component to color \" + (i+1))\n          .appendTo($tools);\n      let $bs = Q.span(\" \").addClass(\"icon-color\")\n          .css(\"background\", hex_to_rgb(hex))\n          .appendTo($b);\n    });\n\n    this.update_tool = (toolname) => {\n      $div.query(\".icon-button\").forEach($e => {\n        let button_tool = $e.prop(\"data-tool\");\n        if (typeof button_tool === \"string\") {\n          $e.toggleClass(\"active\", button_tool === toolname);\n        }\n      });\n    };\n    this.update_tool(global_tool_state.tool);\n\n    $tools.on(\"click\", e => {\n      let el = e.target.closest('.icon-button');\n      if (el) {\n        let tool = Q(el).prop('data-tool');\n        if (typeof tool === \"string\") {\n          e.preventDefault();\n          e.stopPropagation();\n          global_tool_state.tool = tool;\n          this.update_tool(tool);\n        }\n      }\n    });\n\n    let $mirror = Q.create(\"input\")\n        .prop(\"type\", \"button\")\n        .value(\"Mirror\")\n        .prop(\"title\", \"Change the types of all crossings\")\n        .appendTo($div);\n    $mirror.on(\"click\", e => {\n      let view = this.copy();\n      view.diagram.adjs.forEach(a => {\n        a.push(a.shift());\n      });\n      undo_stack.push(view);\n    });\n\n    let $invert = Q.create(\"input\")\n        .prop(\"type\", \"button\")\n        .value(\"Invert\")\n        .prop(\"title\", \"Change orientations of each component\")\n        .appendTo($div);\n    $invert.on(\"click\", e => {\n      let view = this.copy();\n      view.diagram.edges.forEach(edge => {\n        let t_vert = edge[0];\n        edge[0] = edge[1];\n        edge[1] = t_vert;\n      });\n      view.diagram.adjs = view.diagram.adjs.map(a => a.map(d => -d));\n      undo_stack.push(view);\n    });\n\n    let $alternating = Q.create(\"input\")\n        .prop(\"type\", \"button\")\n        .value(\"Make alternating\")\n        .prop(\"title\", \"Change types of crossings to make an alternating diagram\")\n        .appendTo($div);\n    $alternating.on(\"click\", e => {\n      let view = this.copy();\n      view.diagram.make_alternating();\n      undo_stack.push(view);\n    });\n    $div.append(Q.create(\"input\", {type: \"button\",\n                                   title: \"Assign distinct colors to each component\"})\n                .value(\"Auto-color\")\n                .on(\"click\", e => {\n                  let view = this.copy();\n                  view.diagram.auto_color(palette.length);\n                  undo_stack.push(view);\n                }));\n\n    $div.append(Q.create(\"br\"));\n\n    let $to_drawing = Q.create(\"input\")\n        .prop(\"type\", \"button\")\n        .value(\"Convert to drawing\")\n        .prop(\"title\", \"Convert the diagram back into a drawing for free-form editing (no round-trip guarantee)\")\n        .appendTo($div);\n    $to_drawing.on(\"click\", e => {\n      let canvas = document.createElement(\"canvas\");\n      canvas.width = this.width;\n      canvas.height = this.height;\n      let ctxt = canvas.getContext(\"2d\");\n      this.paint(ctxt, false);\n      let view = new KnotRasterView(this.width, this.height);\n      view.fromImage(ctxt.getImageData(0, 0, this.width, this.height));\n      undo_stack.push(view);\n    });\n\n    $div.append(Q.create(\"h2\").append(\"Isotopy tools\"));\n\n/*    let $smooth = Q.create(\"input\")\n        .prop(\"type\", \"button\")\n        .value(\"Smooth\")\n        .prop(\"title\", \"Smooth the diagram a little (not very well)\")\n        .appendTo($div);\n    $smooth.on(\"click\", e => {\n      let view = this.copy();\n      view.diagram.smooth();\n      undo_stack.push(view);\n    });*/\n\n    /*\n    let $simplify_mesh = Q.create(\"input\")\n        .prop(\"type\", \"button\")\n        .value(\"Simplify mesh\")\n        .prop(\"title\", \"Simplify the geometry of the diagram\")\n        .appendTo($div);\n    $simplify_mesh.on(\"click\", e => {\n      let view = this.copy();\n      view.diagram.simplify_mesh(5);\n      view.diagram.compact();\n      undo_stack.push(view);\n    });*/\n\n    let $beautify = Q.create(\"input\")\n        .prop(\"type\", \"button\")\n        .value(\"Beautify\")\n        .prop(\"title\", \"Redraw using a Tutte embedding of a barycentric subdivision of the diagram\")\n        .appendTo($div);\n    $beautify.on(\"click\", e => {\n      let view = this.copy();\n      view.diagram.beautify();\n      undo_stack.push(view);\n    });\n\n    $div.append(Q.create(\"hr\"));\n\n    $div.append(Q.create(\"h2\").append(\"Diagram information\"));\n\n    let $idiv = Q.create(\"div\").prop(\"id\", \"diag-info\").appendTo($div);\n    {\n      let $table = Q.create(\"table\", {className:\"diag-props\"});\n      $idiv.append($table);\n\n      $table.append(Q.create(\"tr\",\n                             Q.create(\"th\", \"Crossings:\"),\n                             Q.create(\"td\", ''+this.diagram.crossing_number())));\n\n      $table.append(Q.create(\"tr\",\n                             Q.create(\"th\", \"Components:\"),\n                             Q.create(\"td\", ''+this.diagram.num_components())));\n\n\n      $table.append(Q.create(\"tr\",\n                             Q.create(\"th\", \"Writhe:\"),\n                             Q.create(\"td\", ''+this.diagram.writhe())));\n\n      $table.append(Q.create(\"tr\",\n                             Q.create(\"th\", \"Bridges:\"),\n                             Q.create(\"td\", ''+this.diagram.bridge_number())));\n\n\n      $table.append(Q.create(\"tr\", {title: \"The canonical Seifert genus for this diagram\"},\n                             Q.create(\"th\", \"Can. genus:\"),\n                             Q.create(\"td\", ''+this.diagram.genus())));\n\n      let turaev = this.diagram.turaev();\n      $table.append(Q.create(\"tr\",\n                             Q.create(\"th\", \"Turaev genus:\"),\n                             Q.create(\"td\", ''+turaev.genus)));\n\n\n      let props = [];\n      if (diagram.is_alternating()) {\n        props.push(\"alternating\");\n      }\n\n      if (turaev.plus && turaev.minus) {\n        props.push(\"adequate\");\n      } else if (turaev.plus) {\n        props.push(\"plus-adequate\");\n      } else if (turaev.minus) {\n        props.push(\"minus-adequate\");\n      }\n\n      $table.append(Q.create(\"tr\",\n                             Q.create(\"th\", \"Properties:\"),\n                             Q.create(\"td\", props.length > 0 ? props.join(\", \") : Q.create(\"em\", \"none\"))));\n\n      let $lm = Q.create(\"details\",\n                         {title: \"Pairwise linking numbers between colored components. Self linking number is writhe.\"},\n                         Q.create(\"summary\", \"Linking matrix\"))\n          .appendTo($idiv);\n      attach_details_handler(\"linking-matrix\", $lm);\n      {\n        let matrix = this.diagram.linking_matrix();\n        let comps = Array.from(matrix.keys());\n        comps.sort((a, b) => a-b);\n        let $table = Q.create(\"table\").addClass(\"linking-matrix\");\n        comps.forEach(j => {\n          let $tr = Q.create(\"tr\").appendTo($table);\n          comps.forEach(i => {\n            let $td = Q.create(\"td\").appendTo($tr);\n            $td.append(''+(matrix.get(j).get(i)||0));\n            if (i === j) {\n              $td.prop(\"style\").color = \"white\";\n              $td.prop(\"style\").background = hex_to_rgb(palette[i-1]);\n            }\n          });\n        });\n        $lm.append($table);\n      }\n    }\n\n    let $sf = Q.create(\"details\",\n                       {title:\"There is one Seifert linking matrix per connected component of the diagram.\"},\n                       Q.create(\"summary\", \"Seifert form\"))\n        .appendTo($idiv);\n\n    attach_details_handler(\"seifert-matrix\", $sf);\n\n    //let the_signature = 0;\n    diagram.seifert_form().forEach(matrix => {\n      let $table = Q.create(\"table\", {className:\"seifert-matrix\"});\n      matrix.forEach(row => {\n        let $tr = Q.create(\"tr\").appendTo($table);\n        row.forEach(c => {\n          $tr.append(Q.create(\"td\", ''+c));\n        });\n      });\n      $sf.append($table);\n\n      // // compute A + A^T\n      // let two_cover = matrix.map(row => row.slice());\n      // for (let i = 0; i < matrix.length; i++) {\n      //   for (let j = 0; j < matrix.length; j++) {\n      //     two_cover[i][j] += matrix[j][i];\n      //   }\n      // }\n      //\n      // the_signature += signature(two_cover);\n    });\n\n    let $pd = Q.create(\"textarea\")\n        .attr(\"readonly\", true)\n        .addClass(\"code-data\");\n    let $pdtypes = Q.create(\"form\", {className: \"inline-form\"},\n                            Q.create(\"label\",\n                                     Q.create(\"input\", {type: \"radio\",\n                                                        name: \"pd-type\",\n                                                        value: \"KnotTheory\"}),\n                                     \"KnotTheory\"),\n                            Q.create(\"label\",\n                                     Q.create(\"input\", {type: \"radio\",\n                                                        name: \"pd-type\",\n                                                        value: \"KnotTheory-oriented\"}),\n                                     \"Oriented KnotTheory\"),\n                            Q.create(\"label\",\n                                     Q.create(\"input\", {type: \"radio\",\n                                                        name: \"pd-type\",\n                                                        value: \"SnapPy\"}),\n                                     \"SnapPy\"),\n                           );\n    function pd_change(name) {\n      $pdtypes[0].elements['pd-type'].value = default_pd_type = name;\n      try {\n        if (name === \"KnotTheory\") {\n          $pd.value(diagram.get_pd().toMathematica());\n        } else if (name === \"KnotTheory-oriented\") {\n          $pd.value(diagram.get_pd(true).toMathematica());\n        } else if (name === \"SnapPy\") {\n          $pd.value(diagram.get_pd().toSnappy());\n        }\n      } catch (x) {\n        $pd.value(\"\" + x);\n      }\n    }\n    $pdtypes.on(\"change\", function (e) {\n      let name = this.elements['pd-type'].value;\n      pd_change(name);\n    });\n    $idiv.append(Q.create(\"p\")\n                 .append(\"PD: \")\n                 .append($pdtypes, Q.create(\"br\"), $pd));\n    pd_change(default_pd_type);\n\n    let dt = diagram.get_dt();\n    if (dt) {\n      $idiv.append(Q.create(\"p\", {title: \"The Dowker-Thistlethwaite code for the knot.\"})\n                   .append(\"DT: \" + toString(dt)));\n    }\n\n    function laurent_invariant(promise, div, variable=\"t\", exp_divisor=1) {\n      promise.then(poly => {\n        if (poly) {\n          div.append(poly.toDOM(variable, exp_divisor));\n        } else {\n          div.append(\"n/a\");\n        }\n      }, err => {\n        console.log(err);\n        div.addClass(\"calc-error\");\n        div.append('Error: '+err);\n      });\n    }\n\n    var $kb_div;\n    $idiv.append(Q.create(\"p\")\n                 .append(\"Kauffman bracket:\")\n                 .append($kb_div = Q.create(\"div\")));\n    laurent_invariant(get_invariant(\"kauffman_bracket\", this.diagram), $kb_div, \"A\");\n\n    $idiv.append(Q.create(\"h2\").append(\"Identification\"));\n    let $ident = Q.create(\"p\").appendTo($idiv);\n    get_invariant('identify_link', this.diagram).then(\n      res => {\n        if (res.names.length === 0) {\n          $ident.append(\"Unknown link\");\n        } else {\n          $ident.append(\"Candidates: \");\n          res.names.forEach((c, i) => {\n            if (i > 0) {\n              $ident.append(\", \");\n            }\n            if (c.katlas) {\n              $ident.append(Q.create(\"a\", {href: c.katlas,\n                                           target: \"_blank\"},\n                                     c.name));\n            } else {\n              $ident.append(c.name);\n            }\n          });\n        }\n        if (res.incomplete) {\n          $ident.append(\" (warning: possibly incomplete)\");\n        }\n      },\n      err => {\n        console.error(err);\n        $ident.addClass(\"calc-error\");\n        $ident.append('Error: '+err);\n      }\n    );\n\n    $idiv.append(Q.create(\"h2\").append(\"Invariants\"));\n\n    {\n      let $table = Q.create(\"table\", {className:\"diag-props\"});\n      $idiv.append($table);\n\n      let $det;\n      $table.append(Q.create(\"tr\",\n                             Q.create(\"th\", \"Determinant:\"),\n                             $det = Q.create(\"td\")));\n\n      (async function () {\n        let poly = await get_invariant(\"alexander_poly\", diagram, 0);\n        let coeffs = poly.coeffs();\n        let det = 0;\n        for (let i = 0; i < coeffs.length; i++) {\n          det += coeffs[i] * (2 * (i % 2) - 1);\n        }\n        $det.append('' + Math.abs(det));\n      })();\n\n      // let $sig;\n      // $table.append(Q.create(\"tr\", {title: \"The program currently uses floating point arithmetic to compute eigenvalues, hence the warning.\"},\n      //                        Q.create(\"th\", \"Signature:\"),\n      //                        $sig = Q.create(\"td\", ''+the_signature+\" \",\n      //                                        Q.create(\"em\", \"(warning: estimated)\"))));\n\n\n      let $jones;\n      $idiv.append(Q.create(\"p\")\n                   .append(\"Jones polynomial:\")\n                   .append($jones = Q.create(\"div\")));\n      laurent_invariant(get_invariant('jones_poly', this.diagram), $jones, \"t\", 2);\n\n      if (0) {\n        let wp = get_invariant(this.diagram, 'wirtinger_presentation');\n        let gens = Q.create(\"div\").append(\"Generators: \");\n        wp.gens.forEach((g, i) => {\n          if (i > 0) {\n            gens.append(\", \");\n          }\n          gens.append(showGen(g));\n        });\n        let rels = Q.create(\"div\").append(\"Relations: \");\n        wp.rels.forEach((rel, i) => {\n          if (i > 0) {\n            rels.append(\", \");\n          }\n          rels.append(showRel(rel));\n        });\n        $idiv.append(Q.create(\"p\")\n                     .append(\"Wirtinger presentation:\")\n                     .append(gens)\n                     .append(rels));\n        function showGen(g) {\n          let s = Q.create(\"span\").append(g[0]);\n          s.append(Q.create(\"sub\").append(g.slice(1)));\n          return s;\n        }\n        function showRel(rel) {\n          let s = Q.create(\"span\");\n          for (let i = 0; i < rel.length; i += 2) {\n            s.append(showGen(rel[i]));\n            if (rel[i+1] !== 1) {\n              s.append(Q.create(\"sup\").append(''+rel[i+1]));\n            }\n          }\n          return s;\n        }\n      }\n\n\n      let $conway_poly;\n      $idiv.append(Q.create(\"p\")\n                   .append(\"Conway potential:\")\n                   .append($conway_poly = Q.create(\"div\")));\n      laurent_invariant(get_invariant(\"conway_poly\", diagram), $conway_poly, \"z\");\n\n      let $alex_polys = Q.create(\"p\").append(\"Alexander polynomials:\").appendTo($idiv);\n      (async function () {\n        try {\n          for (let n = 0; ; n++) {\n            let poly = await get_invariant(\"alexander_poly\", diagram, n);\n            if (n >= 1 && poly.equal(Laurent.unit)) {\n              break;\n            }\n            $alex_polys.append(Q.create(\"br\"));\n            $alex_polys.append(\"\\u0394\");\n            $alex_polys.append(Q.create(\"sup\").append(''+n));\n            $alex_polys.append(\"(t) = \", poly.toDOM(\"t\"));\n          }\n        } catch (x) {\n          $alex_polys.append(Q.create(\"div\", {className: \"calc-error\"}, ''+x));\n          throw x;\n        }\n      })();\n\n      let $alex_mod = Q.create(\"details\",\n                               {title:\"Mildly simplified (not normalized since Z[t,t^-1] is not a PID)\"},\n                               Q.create(\"summary\", \"An Alexander module presentation matrix:\"))\n          .appendTo($idiv);\n      attach_details_handler(\"alexander-module\", $alex_mod);\n      (async function () {\n        let matrix = await get_invariant('alexander_module', diagram);\n        let $table = Q.create(\"table\").addClass(\"alexander-matrix\");\n        matrix.forEach(row => {\n          let $tr = Q.create(\"tr\").appendTo($table);\n          row.forEach(entry => {\n            let $td = Q.create(\"td\").appendTo($tr);\n            $td.append(entry.toDOM(\"t\"));\n          });\n        });\n        $alex_mod.append($table);\n        $alex_mod.append(Q.create(\"em\").append(\"(\" + matrix.length + \" generator(s))\"));\n      })();\n\n    }\n    \n    return $div;\n  }\n\n  paint(ctxt, with_arrows=true) {\n    ctxt.save();\n    ctxt.fillStyle = \"white\";\n    ctxt.fillRect(0, 0, this.width, this.height);\n\n    let getX = (x) => {\n      return x/this.zoom+this.c.x;\n    };\n    let getY = (y) => {\n      return y/this.zoom+this.c.y;\n    };\n\n    let diag = this.diagram;\n\n    let seen_darts = new Set;\n\n    let visit_dart = (dart) => {\n      if (seen_darts.has(dart)) return;\n\n      // locate beginning of path\n      function opp_is_under(d) {\n        /* Is the  opposite of the dart an under-dart? */\n        d = diag.opp_dart(d);\n        return diag.dart_order(d) === 4 && !diag.dart_is_over(d);\n      }\n      // Switch to opposite orientation if needed, then walk until we get to beginning of arc.\n      if (diag.dart_start(dart) === diag.dart_edge(dart)[0]) {\n        dart = diag.opp_dart(dart);\n      }\n      let d = dart;\n      while (!opp_is_under(d)) {\n        d = diag.through_dart(d);\n        if (d === dart) break;\n      }\n      dart = diag.opp_dart(d);\n      // now dart is beginning of an arc (or some random dart from a loop)\n\n      let path = [];\n      let loop = false;\n      d = dart;\n      while (true) {\n        seen_darts.add(d);\n        seen_darts.add(diag.opp_dart(d));\n        path.push(diag.verts[diag.dart_start(d)]);\n        if (opp_is_under(d)) {\n          path.push(diag.verts[diag.dart_end(d)]);\n          break;\n        }\n        if (path.length > 1 && d === dart) {\n          loop = true;\n          break;\n        }\n        d = diag.through_dart(d);\n      }\n\n      if (!loop) {\n        let to_remove = CROSSING_GAP * this.zoom;\n        while (to_remove > 0 && path.length >= 2) {\n          let d = Point.dist(path[0], path[1]);\n          if (d <= to_remove) {\n            to_remove -= d;\n            path.shift();\n          } else {\n            path[0] = point_along(path[0], path[1], to_remove/d);\n            break;\n          }\n        }\n        to_remove = CROSSING_GAP * this.zoom;\n        while (to_remove > 0 && path.length >= 2) {\n          let d = Point.dist(path[path.length-2], path[path.length-1]);\n          if (d <= to_remove) {\n            to_remove -= d;\n            path.pop();\n          } else {\n            path[path.length-1] = point_along(path[path.length-1], path[path.length-2], to_remove/d);\n            break;\n          }\n        }\n      }\n\n      ctxt.beginPath();\n      ctxt.moveTo(getX(path[0].x)+0.5, getY(path[0].y)+0.5);\n      for (let i = 1; i < path.length; i++) {\n        let v = path[i];\n        ctxt.lineTo(getX(v.x)+0.5, getY(v.y)+0.5);\n      }\n      ctxt.strokeStyle = hex_to_rgb(palette[diag.dart_edge(dart)[2]-1]);\n      ctxt.lineWidth = DIAGRAM_LINE_WIDTH;\n      ctxt.lineCap = \"round\";\n      ctxt.stroke();\n\n      // arrow head\n      if (with_arrows) {\n        let p = path[path.length-1];\n        let dx = 0, dy = 0;\n        let dist = 5;\n        for (let i = path.length-2; i >= 0 && dist > 0; i--) {\n          let p1 = path[i], p2 = path[i+1];\n          dx += p2.x - p1.x;\n          dy += p2.y - p1.y;\n          dist -= Point.dist(p1, p2);\n        }\n        let norm = Math.sqrt(dx*dx + dy*dy);\n        if (norm > 0) {\n          dx /= norm;\n          dy /= norm;\n          ctxt.beginPath();\n          function f_x(x, y) {\n            // x is in direction of arrow tip\n            return getX(p.x) + dx*x - dy*y + 0.5;\n          }\n          function f_y(x, y) {\n            return getY(p.y) + dy*x + dx*y + 0.5;\n          }\n          ctxt.moveTo(f_x(-5, 2), f_y(-5, 2));\n          ctxt.lineTo(f_x(0, 0), f_y(0, 0));\n          ctxt.lineTo(f_x(-5, -2), f_y(-5, -2));\n          ctxt.stroke();\n        }\n      }\n    };\n\n    diag.edges.forEach((e, i) => {\n      visit_dart(i+1);\n    });\n\n    if (0) {\n      ctxt.fillStyle = \"white\";\n      ctxt.globalAlpha = 1.0;\n      diag.verts.forEach(pt => {\n        ctxt.fillRect(getX(pt.x), getY(pt.y), 2, 2);\n      });\n    }\n\n    ctxt.restore();\n  }\n}\n","// View for painting knots\n\nimport {assert, clamp, hex_to_rgb} from \"./util.mjs\";\nimport {MIN_LINE_LENGTH, MAX_PPREV_DIST, ERASE_RADIUS, PAINT_RADIUS, DIAGRAM_LINE_WIDTH,\n        PAINT_GAP, WIDTH, HEIGHT, ERROR_RADIUS, SPUR_LENGTH, palette} from \"./constants.mjs\";\nimport {Point, line_points, lines_intersect, segment_contains, segments_intersect, pseudo_angle} from \"./geom2d.mjs\";\nimport {KnotGraph} from \"./knotgraph.mjs\";\nimport {KnotImageImportView} from \"./KnotImageImportView.mjs\";\nimport {KnotDiagramView} from \"./KnotDiagramView.mjs\";\nimport Q from \"./kq.mjs\";\n\nconst EPSILON = 1e-2;\n\nlet global_painting_state = {\n  mode: \"pencil\",\n  color: 1,\n  go_over: 1\n};\n\nexport class KnotRasterView {\n  constructor(width, height) {\n    assert(width > 0);\n    assert(height > 0);\n    this.width = width;\n    this.height = height;\n    this.buffer = new Int8Array(this.width * this.height);\n    this.temp = new Int8Array(this.width * this.height);\n\n    this.mode_name = \"Painting\"; // constant\n    this.next_knot = null;\n  }\n  \n  copy() {\n    let kb = new KnotRasterView(this.width, this.height);\n    kb.buffer.set(this.buffer);\n    return kb;\n  }\n\n  mousedown(pt, e, undo_stack, ctxt) {\n    if (e.button === 0 || e.button === 2) {\n      if (this.next_knot) {\n        this.mousemove(pt, e, undo_stack, ctxt);\n        return;\n      }\n      this.next_knot = this.copy();\n      if (e.button === 0) {\n        if (global_painting_state.mode === \"eraser\") {\n          this.the_color = 0;\n        } else {\n          this.the_color = global_painting_state.color;\n        }\n      } else {\n        this.the_color = 0;\n        if (this.mark_tool) {\n          this.mark_tool(\"eraser\");\n        }\n      }\n      let go_over = global_painting_state.go_over * (e.shiftKey ? -1 : 1);\n      this.mark_height(go_over);\n      this.next_knot.draw_line(null, null, pt, this.the_color, go_over);\n      this.pprev = [];\n      this.pt1 = pt;\n      this.paint(ctxt);\n    }\n  }\n  mousemove(pt2, e, undo_stack, ctxt) {\n    if (this.next_knot) {\n      if (Point.dist(this.pt1, pt2) < MIN_LINE_LENGTH) {\n        return;\n      }\n      let go_over = global_painting_state.go_over * (e.shiftKey ? -1 : 1);\n      this.mark_height(go_over);\n      this.next_knot.draw_line(this.pprev, this.pt1, pt2, this.the_color, go_over);\n      this.pprev.push(this.pt1);\n      this.pt1 = pt2;\n\n      { // Keep only MAX_PPREV_DIST of pprev.\n        let length = Point.dist(this.pprev[this.pprev.length-1], this.pt1);\n        for (let i = 1; i + 1 < this.pprev.length; i++) {\n          length += Point.dist(this.pprev[i], this.pprev[i+1]);\n        }\n        while (length >= MAX_PPREV_DIST && this.pprev.length > 2) {\n          this.pprev.shift();\n          length -= Point.dist(this.pprev[0], this.pprev[1]);\n        }\n      }\n\n      this.paint(ctxt);\n    }\n  }\n  mouseup(pt, e, undo_stack, ctxt) {\n    if (this.next_knot) {\n      this.mousemove(pt, e, undo_stack, ctxt);\n      let knot = this.next_knot;\n      this.next_knot = null;\n      undo_stack.push(knot);\n    }\n  }\n  toolbox(undo_stack) {\n    let $div = this.$div = Q.div();\n\n    /* Tools */\n    $div.append(\n      Q.create(\"div\",\n               Q.create(\"h2\", \"Tools\"),\n\n               Q.create(\"span\", {\"data-tool\": \"pencil\",\n                                 title: \"Pencil\",\n                                 className: \"icon-button\"},\n                        Q.create(\"span\", {className: \"icon24-pencil\"})),\n\n               Q.create(\"span\", {\"data-tool\": \"eraser\",\n                                 title: \"Eraser [right click]\",\n                                 className: \"icon-button\"},\n                        Q.create(\"span\", {className: \"icon24-eraser\"}))\n              )\n        .on(\"click\", e => {\n          let el = e.target.closest('.icon-button');\n          if (el) {\n            let mode = el['data-tool'];\n            if (mode) {\n              e.preventDefault();\n              e.stopPropagation();\n              global_painting_state.mode = mode;\n              this.mark_tool(mode);\n            }\n          }\n        })\n    );\n\n    this.mark_tool = function (toolname) {\n      /* Set a tool button to be active, depending on the mode */\n\n      $div.query(\".icon-button\").forEach($e => {\n        let button_tool = $e.prop(\"data-tool\");\n        if (typeof button_tool === \"string\") {\n          $e.toggleClass(\"active\", button_tool === toolname);\n        }\n      });\n    };\n    this.mark_tool(global_painting_state.mode);\n\n    /* Over/under */\n    $div.append(\n      Q.create(\"div\",\n               Q.create(\"h2\").append(\"Pencil mode\"),\n\n               /* over */\n               Q.create(\"span\", {\"data-height\": 1,\n                                 title: \"Go over\",\n                                 className: \"icon-button\"},\n                        Q.create(\"span\", {className: \"icon24-go-over\"})),\n               /* same */\n               Q.create(\"span\", {\"data-height\": 0,\n                                 title: \"Go through (no auto-gaps)\",\n                                 className: \"icon-button\"},\n                        Q.create(\"span\", {className: \"icon24-go-through\"})),\n               /* under */\n               Q.create(\"span\", {\"data-height\": -1,\n                                 title: \"Go under [shift]\",\n                                 className: \"icon-button\"},\n                        Q.create(\"span\", {className: \"icon24-go-under\"})),\n\n              )\n        .on(\"click\", e => {\n          let el = e.target.closest('.icon-button');\n          if (el) {\n            let height = Q(el).prop(\"data-height\");\n            if (typeof height === \"number\") {\n              e.preventDefault();\n              e.stopPropagation();\n              global_painting_state.go_over = height;\n              this.mark_height(height);\n              global_painting_state.mode = \"pencil\";\n              this.mark_tool(\"pencil\");\n            }\n          }\n        })\n    );\n\n    this.mark_height = function (go_over) {\n      $div.query(\".icon-button\").forEach($e => {\n        let button_height = $e.prop(\"data-height\");\n        if (typeof button_height === \"number\") {\n          $e.toggleClass(\"active\", go_over === button_height);\n        }\n      });\n    };\n    this.mark_height(global_painting_state.go_over);\n\n    { /* Colors */\n      let $colors = Q.div().appendTo($div);\n      $colors.append(Q.create(\"h2\", \"Pencil colors\"));\n      palette.forEach((hex, i) => {\n        $colors.append(Q.create(\"span\", {className: \"icon-button\",\n                                         \"data-color\": i+1,\n                                         title: \"Color \" + (i+1)},\n                                Q.create(\"span\", {className: \"icon-color\"})\n                                .css(\"background\", hex_to_rgb(hex))));\n      });\n      $colors.on(\"click\", e => {\n        let el = e.target.closest('.icon-button');\n        if (el) {\n          let color = Q(el).prop(\"data-color\");\n          if (color) {\n            e.preventDefault();\n            e.stopPropagation();\n            global_painting_state.color = color;\n            this.mark_color(color);\n            global_painting_state.mode = \"pencil\";\n            this.mark_tool(\"pencil\");\n          }\n        }\n      }, true);\n\n      this.mark_color = function (i) {\n        /* Set a color button to be active, depending on the color index i. */\n        $colors.query(\".icon-button\").forEach(b => {\n          b.toggleClass(\"active\", b.prop(\"data-color\") === i);\n        });\n      };\n      this.mark_color(global_painting_state.color);\n    }\n\n    $div.append(Q.create(\"br\"));\n\n    $div.append(\n      Q.create(\"label\", {title: \"Load an image from a file (can also drag and drop from the filesystem or sometimes copy and paste)\"},\n               \"Load image: \",\n               Q.create(\"input\", {type: \"file\", accept: \"image/*\"})\n               .on(\"change\", e => {\n                 let file = e.target.files[0];\n                 if (file) {\n                   let reader = new FileReader();\n                   reader.readAsDataURL(file);\n                   reader.onloadend = () => {\n                     let img = document.createElement(\"img\");\n                     img.onload = () => {\n                       undo_stack.push(new KnotImageImportView(WIDTH, HEIGHT, img));\n                     };\n                     img.src = reader.result;\n                   };\n                 }\n               })\n              ));\n\n    $div.append(Q.create(\"hr\"));\n\n    $div.append(Q.create(\"input\", {type: \"button\",\n                                   title: \"Find cores of curves by morphological thinning\"})\n                .value(\"Clean up\")\n                .on(\"click\", e => {\n                  let knot = this.copy();\n                  knot.clean_up();\n                  undo_stack.push(knot);\n                }));\n\n    $div.append(Q.create(\"br\"));\n\n    $div.append(Q.create(\"input\", {type: \"button\",\n                                   title: \"Clear boundary pixels of curves\"})\n                .value(\"Thin\")\n                .on(\"click\", e => {\n                  let knot = this.copy();\n                  knot.thin();\n                  undo_stack.push(knot);\n                }));\n\n    $div.append(Q.create(\"input\", {type: \"button\",\n                                   title: \"Add boundary pixels to curves\"})\n                .value(\"Thicken\")\n                .on(\"click\", e => {\n                  let knot = this.copy();\n                  knot.thicken();\n                  undo_stack.push(knot);\n                }));\n\n    $div.append(Q.create(\"hr\"));\n\n    $div.append(Q.create(\"input\", {type: \"button\",\n                                   title: \"Analyze picture and convert to a diagram\"})\n                .value(\"Convert to diagram\")\n                .on(\"click\", e => {\n                  undo_stack.push(this.convert());\n                }));\n\n    if (this.the_error) {\n      let $error = Q.div({className: \"error\"},\n                         Q.create(\"h2\", \"Error\"))\n          .appendTo($div);\n      if (this.the_error instanceof Array) {\n        this.the_error.forEach(err => $error.append(Q.p(''+err)));\n      } else {\n        $error.append(Q.p(''+this.the_error));\n      }\n    }\n\n    return $div;\n  }\n\n  paint(ctxt) {\n    let imgdata = ctxt.getImageData(0, 0, this.width, this.height);\n    this.writeImage(imgdata);\n    ctxt.putImageData(imgdata, 0, 0);\n  }\n\n  writeImage(imageData) {\n    /* writes the buffer */\n    assert(imageData.height >= this.height);\n    assert(imageData.width >= this.width);\n    let data = imageData.data;\n    let w = this.width,\n        h = this.height;\n    let buf = this.next_knot ? this.next_knot.buffer : this.buffer;\n    for (let y = 0; y < h; y++) {\n      for (let x = 0; x < w; x++) {\n        let off = w*y+x;\n        let c = buf[off];\n        if (c > 0) {\n          let hex = palette[c-1];\n          data[4*off+0] = (hex >>> 16) & 0xFF;\n          data[4*off+1] = (hex >>> 8) & 0xFF;\n          data[4*off+2] = hex & 0xFF;\n          data[4*off+3] = 255;\n        } else if (c === 0) {\n          data[4*off+0] = 255;\n          data[4*off+1] = 255;\n          data[4*off+2] = 255;\n          data[4*off+3] = 255;\n        } else {\n          // error color\n          data[4*off+0] = 255;\n          data[4*off+1] = 150;\n          data[4*off+2] = 150;\n          data[4*off+3] = 255;\n        }\n      }\n    }\n  }\n\n  fromImage(imageData) {\n    /* Attempts to get buffer out of the imageData. */\n    assert(imageData.height >= this.height);\n    assert(imageData.width >= this.width);\n    let data = imageData.data;\n    let w = this.width,\n        h = this.height;\n    let buf = this.buffer;\n    for (let y = 0; y < h; y++) {\n      for (let x = 0; x < w; x++) {\n        let off = w*y+x;\n        let color = (data[4*off+0] << 16) | (data[4*off+1] << 8) | data[4*off+2];\n        let idx = palette.indexOf(color);\n        if (idx >= 0) {\n          buf[off] = idx + 1;\n        } else {\n          buf[off] = 0;\n        }\n      }\n    }\n  }\n\n  draw_line(pprev, p1, p2, v, go_over = 1) {\n    /* Draw a line from p1 to p2, given that there had already been a\n       line through the points in the array pprev to p1.  We allow pprev\n       to be null, meaning this is a fresh start.  If pprev is null, then\n       we allow p1 to be null, meaning this is the first point. */\n    let buf = this.buffer;\n    let temp = this.temp;\n\n    let width = 0|this.width,\n        height = 0|this.height;\n\n    //console.log(\"draw_line([\"+pprev+'],'+p1+','+p2+','+v+','+go_over+')');\n\n    let getPixel = (x, y) => {\n      if (0 <= x && x < width && 0 <= y && y < height) {\n        return buf[y*width + x];\n      } else {\n        return 0;\n      }\n    };\n    let setPixel = (x, y, v) => {\n      if (0 <= x && x < width && 0 <= y && y < height) {\n        buf[y*width + x] = v;\n      }\n    };\n    let getTempPixel = (x, y) => {\n      if (0 <= x && x < width && 0 <= y && y < height) {\n        return temp[y*width + x];\n      } else {\n        return -1;\n      }\n    };\n    let setTempPixel = (x, y, v) => {\n      if (0 <= x && x < width && 0 <= y && y < height) {\n        temp[y*width + x] = v;\n      }\n    };\n\n\n    function with_radius(x, y, r, f) {\n      /* Calls f with all pairs within a box of radius r of the given (x,y) point. */\n      for (let j = -r; j <= r; j++) {\n        for (let i = -r; i <= r; i++) {\n          f(x + i, y + j);\n        }\n      }\n    }\n\n    if (v === 0) {\n      // This is erase mode\n      for (let p of line_points(p1 || p2, p2)) {\n        with_radius(p.x, p.y, ERASE_RADIUS, (x, y) => setPixel(x, y, 0));\n      }\n    } else {\n      // This is draw mode\n\n      temp.fill(-1);\n      // non-negative means something to write.\n      // -2 marks pre-existing stuff that won't be re-written.\n\n      function find_existing(r, x, y) {\n        if (r < 0 || getTempPixel(x, y) !== -1 || getPixel(x, y) !== v) {\n          return;\n        }\n        setTempPixel(x, y, -2);\n        with_radius(x, y, 1, (x2, y2) => find_existing(r-1, x2, y2));\n      }\n\n      p1 = p1 || p2;\n\n      // See if this is, roughly, the start of a new line\n      let p0 = null;\n      if (pprev === null || pprev.length === 0) {\n        p0 = p1;\n      } else {\n        let length = Point.dist(p1, p2);\n        let last_p = p1;\n        for (let i = pprev.length-1; i >= 0; i--) {\n          length += Point.dist(last_p, pprev[i]);\n          last_p = pprev[i];\n        }\n        if (length <= MAX_PPREV_DIST) {\n          p0 = pprev[0];\n        }\n      }\n      if (p0 !== null) {\n        // Start of a new line, so look for anything it might be extending.\n        with_radius(p0.x, p0.y, PAINT_RADIUS+1, (x, y) => find_existing(PAINT_RADIUS + PAINT_GAP, x, y));\n      }\n\n      // mark everything in the line through pprev to p1 as being part of the current line\n      if (pprev !== null) {\n        let last_p = p1;\n        fill_old:\n        for (var i = pprev.length-1; i >= 0; i--) {\n          for (let p of line_points(last_p, pprev[i])) {\n            if (getPixel(p.x, p.y) === -1) {\n              // for go_over < 0\n              break fill_old;\n            }\n            with_radius(p.x, p.y, PAINT_RADIUS, (x, y) => setTempPixel(x, y, -2));\n          }\n          last_p = pprev[i];\n        }\n      }\n\n      // detect endpoints to suppress white border when closing up\n      if(0)with_radius(p2.x, p2.y, PAINT_RADIUS + PAINT_GAP, (x, y) => {\n        if (getPixel(x, y) !== v || getTempPixel(x, y) !== -1) {\n          return;\n        }\n        var state = -1;\n        var changes = -1;\n        function visit(x2, y2) {\n          if (getTempPixel(x2, y2) === -2) {\n            return;\n          }\n          let c = getPixel(x2, y2);\n          if (c !== state) {\n            state = c;\n            changes++;\n          }\n        }\n        let r = 2*PAINT_RADIUS + PAINT_GAP;\n        // go in counter-clockwise square of radius r about (x,y).\n        for (let x2 = x - r; x2 < x + r; x2++) {\n          visit(x2, y + r);\n        }\n        for (let y2 = y + r; y2 > y - r; y2--) {\n          visit(x + r, y2);\n        }\n        for (let x2 = x + r; x2 > x - r; x2--) {\n          visit(x2, y - r);\n        }\n        for (let y2 = y - r; y2 < y + r; y2++) {\n          visit(x - r, y2);\n        }\n        if (changes === 2) {\n          find_existing(r, x, y);\n        }\n      });\n\n      for (let p of line_points(p1, p2)) {\n        if (go_over > 0) {\n          with_radius(p.x, p.y, PAINT_RADIUS + PAINT_GAP, (x, y) => {\n            if (getTempPixel(x, y) === -1) {\n              setTempPixel(x, y, 0);\n            }\n          });\n          with_radius(p.x, p.y, PAINT_RADIUS, (x, y) => setTempPixel(x, y, v));\n        } else if (go_over < 0) {\n          with_radius(p.x, p.y, PAINT_RADIUS, (x, y) => {\n            let avoid = false;\n            with_radius(x, y, PAINT_GAP, (x2, y2) => {\n              if (getTempPixel(x2, y2) === -1 && getPixel(x2, y2) > 0) {\n                avoid = true;\n              }\n            });\n            if (!avoid) {\n              setTempPixel(x, y, v);\n            }\n          });\n        } else {\n          with_radius(p.x, p.y, PAINT_RADIUS, (x, y) => setTempPixel(x, y, v));\n        }\n      }\n\n      for (let i = 0; i < WIDTH * HEIGHT; i++) {\n        let t = temp[i];\n        if (t >= 0) {\n          buf[i] = t;\n        }\n      }\n    }\n  }\n\n  strip_errors() {\n    let buf = this.buffer;\n    for (let i = 0; i < buf.length; i++) {\n      if (buf[i] < 0) buf[i] = 0;\n    }\n  }\n  add_error(pt, r = ERROR_RADIUS) {\n    assert(pt instanceof Point);\n    let width = 0|this.width;\n    let height = 0|this.height;\n    let buf = this.buffer;\n    let ir = Math.ceil(r);\n    for (let dy = -ir; dy <= ir; dy++) {\n      let y = Math.floor(pt.y) + dy;\n      if (y < 0 || y >= height) {\n        continue;\n      }\n      for (let dx = -ir; dx <= ir; dx++) {\n        let x = Math.floor(pt.x) + dx;\n        if (x < 0 || x >= width) {\n          continue;\n        }\n        if (dx*dx + dy*dy <= r*r && buf[width*y+x] <= 0) {\n          buf[width*y+x] = -1;\n        }\n      }\n    }\n  }\n\n  thin() {\n    /* Remove all pixels that have neighbor not of the same color */\n    let width = 0|this.width;\n    let height = 0|this.height;\n    let buf = this.buffer;\n    let tbuf = this.temp;\n    tbuf.fill(0);\n\n    this.strip_errors();\n\n    // put -1 into tbuf to mark the pixel should be cleared\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        let erase = false;\n        let c = buf[y*width+x];\n        if (y === 0 || y === height - 1) {\n          erase = true;\n        } else if (x === 0 || x === width - 1) {\n          erase = true;\n        } else if (c > 0) {\n          find:\n          for (let dy = -1; dy <= 1; dy++) {\n            for (let dx = -1; dx <= 1; dx++) {\n              if (buf[(y+dy)*width+(x+dx)] !== c) {\n                erase = true;\n                break find; \n              }\n            }\n          }\n        }\n\n        if (erase) {\n          tbuf[y*width+x] = -1;\n        }\n      }\n    }\n\n    // clear pixels marked by tbuf\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        if (tbuf[y*width+x] === -1) {\n          buf[y*width+x] = 0;\n        }\n      }\n    }\n  }\n\n  thicken() {\n    /* Add boundary pixels to colored regions */\n    let width = 0|this.width;\n    let height = 0|this.height;\n    let buf = this.buffer;\n    let tbuf = this.temp;\n    tbuf.fill(0);\n\n    this.strip_errors();\n\n    // put colors into tbuf to mark the pixel should be colored\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        if (buf[y*width+x] > 0) {\n          continue;\n        }\n        let c = 0;\n        find:\n        for (let y2 = y-1; y2 <= y+1; y2++) {\n          if (y2 < 0 || y2 >= height) continue;\n          for (let x2 = x-1; x2 <= x+1; x2++) {\n            if (x2 < 0 || x2 >= width) continue;\n            c = buf[y2*width+x2];\n            if (c > 0)\n              break find;\n          }\n        }\n\n        tbuf[y*width+x] = c;\n      }\n    }\n\n    // set pixels marked by tbuf\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        let c = tbuf[y*width+x];\n        if (c > 0) {\n          buf[y*width+x] = c;\n        }\n      }\n    }\n  }\n\n  clean_up() {\n    let width = 0|this.width;\n    let height = 0|this.height;\n    let buf = this.buffer;\n    let tbuf = this.temp;\n\n    this.strip_errors();\n\n    // clear boundary\n    for (let x = 0; x < width; x++) {\n      buf[width*0+x] = 0;\n      buf[width*(height-1)+x] = 0;\n    }\n    for (let y = 0; y < height; y++) {\n      buf[width*y+0] = 0;\n      buf[width*y+width-1] = 0;\n    }\n\n    // morphological thinning of buf\n\n    let nbuf = new Int8Array(3*3);\n    function mthin(min_pcount, max_pcount) {\n      let changed = false;\n      for (let y = 1; y <= height - 2; y++) {\n        for (let x = 1; x <= width - 2; x++) {\n          let c = buf[width*y+x];\n          if (c <= 0) {\n            continue;\n          }\n          for (let dy = -1; dy <= 1; dy++) {\n            for (let dx = -1; dx <= 1; dx++) {\n              if (buf[width*(y+dy)+(x+dx)] === c) {\n                nbuf[3*(dy+1)+(dx+1)] = 1;\n              } else {\n                nbuf[3*(dy+1)+(dx+1)] = 0;\n              }\n            }\n          }\n          // fill in corners based on direct neighbors\n          if (nbuf[3*0+1]) { // top\n            if (nbuf[3*1+0]) { // left\n              nbuf[3*0+0] = 1;\n            }\n            if (nbuf[3*1+2]) { // right\n              nbuf[3*0+2] = 1;\n            }\n          }\n          if (nbuf[3*2+1]) { // bottom\n            if (nbuf[3*1+0]) { // left\n              nbuf[3*2+0] = 1;\n            }\n            if (nbuf[3*1+2]) { // right\n              nbuf[3*2+2] = 1;\n            }\n          }\n          \n          let state = nbuf[3*1+2];\n          let pcount = 0; // pixel count\n          let ccount = 0; // component changes\n          function step(dx, dy) {\n            let c2 = nbuf[3*(1+dy)+(1+dx)];\n            if (c2 !== state) {\n              ccount++;\n              state = c2;\n            }\n            if (c2 > 0) {\n              pcount++;\n            }\n          }\n          // step counterclockwise around point\n          step(1,1);\n          step(0,1);\n          step(-1,1);\n          step(-1,0);\n          step(-1,-1);\n          step(0,-1);\n          step(1,-1);\n          step(1,0);\n          if (pcount === 0) {\n            // this is isolated vertex\n            buf[width*y+x] = 0;\n            // no need to set changed to true since there are no consequences to removing this\n          } else if (ccount === 2) {\n            // this is not a cut vertex\n            if (min_pcount <= pcount && pcount <= max_pcount) {\n              // this is not an end vertex\n              buf[width*y+x] = 0;\n              changed = true;\n            }\n          }\n        }\n      }\n      return changed;\n    }\n\n    let changed = true;\n    while (changed) {\n      changed = mthin(3, 4);\n      if (!changed) {\n        changed = mthin(2, 6);\n      }\n      //changed = false;\n    }\n\n    // remove tips\n    tbuf.fill(0);\n    for (let y = 1; y <= height - 2; y++) {\n      for (let x = 1; x <= width - 2; x++) {\n        let c = buf[width*y+x];\n        if (c > 0) {\n          let icount = -1;\n          for (let dy = -1; dy <= 1; dy++) {\n            for (let dx = -1; dx <= 1; dx++) {\n              if (buf[width*(y+dy)+(x+dx)] === c) {\n                icount++;\n              }\n            }\n          }\n          if (icount === 1) {\n            tbuf[width*y+x] = 1;\n          }\n        }\n      }\n    }\n    for (let y = 1; y <= height - 2; y++) {\n      for (let x = 1; x <= width - 2; x++) {\n        if (tbuf[width*y+x] > 0) {\n          buf[width*y+x] = 0;\n        }\n      }\n    }\n  }\n\n  convert() {\n    /* Returns a View of either a cleaned up version (with errors) or an interpreted knot diagram. */\n\n    let knot = this.copy();\n    knot.clean_up();\n\n    let width = 0|knot.width,\n        height = 0|knot.height,\n        buf = knot.buffer;\n\n    function n_neighbors(x, y) {\n      /* number of neighbors of same color */\n      let c = buf[y*width+x];\n      let count = -1;\n      for (let dy = -1; dy <= 1; dy++) {\n        for (let dx = -1; dx <= 1; dx++) {\n          if (buf[(y+dy)*width+(x+dx)] === c) {\n            count++;\n          }\n        }\n      }\n      return count;\n    }\n\n    /// Spur deletion\n    \n    function maybe_delete_spur(x, y, gas) {\n      if (gas <= 0) {\n        // this wasn't actually a spur\n        return false;\n      }\n      let count = n_neighbors(x, y);\n      if (count === 0) {\n        return false;\n      } else if (count === 1) {\n        let c = buf[y*width+x];\n        for (let dy = -1; dy <= 1; dy++) {\n          for (let dx = -1; dx <= 1; dx++) {\n            if (!(dx === 0 && dy === 0) && buf[(y+dy)*width+(x+dx)] === c) {\n              buf[y*width+x] = 0;\n              let ok = maybe_delete_spur(x+dx, y+dy, gas-1);\n              if (ok) {\n                return true;\n              } else {\n                // revert!\n                buf[y*width+x] = c;\n                return false;\n              }\n            }\n          }\n        }\n        throw new Error(\"Cannot get here.\");\n      } else {\n        return true;\n      }\n    }\n\n    for (let y = 1; y <= height - 2; y++) {\n      for (let x = 1; x <= width - 2; x++) {\n        if (buf[y*width+x] > 0 && n_neighbors(x, y) === 1) {\n          // this is an endpoint\n          maybe_delete_spur(x, y, SPUR_LENGTH);\n        }\n      }\n    }\n\n    for (let y = 1; y <= height - 2; y++) {\n      for (let x = 1; x <= width - 2; x++) {\n        if (buf[y*width+x] > 0 && n_neighbors(x, y) === 0) {\n          // this is an isolated point\n          buf[y*width+x] = 0;\n        }\n      }\n    }\n\n    /// Locate any junctions (errors)\n\n    let found_error = false;\n    for (let y = 1; y <= height - 2; y++) {\n      for (let x = 1; x <= width - 2; x++) {\n        if (buf[y*width+x] > 0 && n_neighbors(x, y) > 2) {\n          knot.add_error(new Point(x, y));\n          found_error = true;\n        }\n      }\n    }\n    if (found_error) {\n      knot.the_error = \"The marked junctions cannot be interpreted. Usually this is because one of the understrands has fused to the overstrand, which can be fixed with a little erasing.\";\n      return knot;\n    }\n\n    /// Match up endpoints\n\n    // Since we removed isolated points, we know there is an even number of endpoints per color\n\n    // for counting number of times a line crosses:\n    let tknot = knot.copy();\n    tknot.thicken();\n\n    let endpoints = new Map(); // Map(color => [Point])\n    for (let y = 1; y <= height - 2; y++) {\n      for (let x = 1; x <= width - 2; x++) {\n        let c = buf[y*width+x];\n        if (c > 0 && n_neighbors(x, y) === 1) {\n          let ep_list = endpoints.get(c);\n          if (!ep_list) {\n            ep_list = [];\n            endpoints.set(c, ep_list);\n          }\n          ep_list.push(new Point(x, y));\n        }\n      }\n    }\n    function match_up(points, color) {\n      /* Looks for a perfect matching that optimizes a heuristic (sum\n      of distances divided by (number of segments crossed - 1)).*/\n\n      // graph[i][j] == score for path between i and j\n      let graph = new Array(points.length);\n      for (let i = 0; i < points.length; i++) {\n        let row = graph[i] = new Array(points.length);\n        row.fill(Infinity);\n      }\n      // a list of [i,j,score] for i<j, when score < Infinity\n      let all_edges = [];\n      for (let i = 0; i < points.length; i++) {\n        let p1 = points[i];\n        for (let j = i + 1; j < points.length; j++) {\n          let p2 = points[j];\n\n          let d = Point.dist(p1, p2);\n\n          let pcount = 0;\n          let state = -2;\n          for (let lp of line_points(p1, p2)) {\n            let c = tknot.buffer[width*lp.y+lp.x];\n            if (c === 0) {\n              c = 0|tknot.buffer[width*lp.y+(lp.x+1)];\n            }\n            if (c === 0) {\n              c = 0|tknot.buffer[width*(lp.y+1)+lp.x];\n            }\n            if (c !== state) {\n              if (c > 0) {\n                pcount++;\n              }\n              state = c;\n            }\n          }\n          if (pcount > 1) {\n            // Then this is a non-backtracking line segment\n            let count = Math.min(2, pcount-1);\n            let score = (d - DIAGRAM_LINE_WIDTH*count) / count;\n            score = Math.max(0, score);\n            graph[i][j] = score;\n            graph[j][i] = score;\n            all_edges.push([i, j, score]);\n          }\n        }\n      }\n      all_edges.sort((e1, e2) => e1[2] - e2[2]);\n\n      // construct match greedily\n\n      let used_points = Array(points.length).fill(false);\n      let edges = [];\n      all_edges.forEach(edge => {\n        if (used_points[edge[0]] || used_points[edge[1]]) {\n          return;\n        }\n        edges.push([edge[0], edge[1]]);\n        used_points[edge[0]] = true;\n        used_points[edge[1]] = true;\n      });\n\n      if (2 * edges.length < points.length) {\n        // Couldn't match everything up.  Return a too-short match\n        let err_points = [];\n        for (let i = 0; i < used_points.length; i++) {\n          if (!used_points[i]) {\n            err_points.push(points[i]);\n          }\n        }\n        return {err_points:err_points};\n      }\n\n      // look for pairs of edges where one of the other two pairings are better\n      let swaps = 0;\n      let keep_going = true;\n      while (keep_going) {\n        keep_going = false;\n        for (let i = 0; i < edges.length; i++) {\n          for (let j = i + 1; j < edges.length; j++) {\n            let [p1, p2] = edges[i],\n                [q1, q2] = edges[j];\n            let d1 = graph[p1][p2] + graph[q1][q2],\n                d2 = graph[p1][q1] + graph[p2][q2],\n                d3 = graph[p1][q2] + graph[q1][p2];\n            if (d2 < d1 && d2 <= d3) {\n              edges[i][1] = q1;\n              edges[j][0] = p2;\n              keep_going = true;\n              swaps++;\n            } else if (d3 < d1 && d3 <= d2) {\n              edges[i][1] = q2;\n              edges[j][1] = p2;\n              keep_going = true;\n              swaps++;\n            }\n          }\n        }\n      }\n      console.log(\"swaps= \" + swaps);\n\n      return edges.map(edge => [points[edge[0]], points[edge[1]]]);\n    }\n\n    // Collect the matching now.\n    let matches = []; // [p1, p2, color]\n    let errors = [];\n    endpoints.forEach((points, color) => {\n      let match = null;\n      match = match_up(points, color);\n      if (match.err_points) {\n        found_error = true;\n        match.err_points.forEach(pt => knot.add_error(pt));\n        errors.push(\"Couldn't find a way to match up endpoints in the component of color \"\n                    + color + \".  The unmatched points have been marked.\");\n        return;\n      }\n      match.forEach(edge => {\n        // check that the matching's edges do not intersect so far\n        matches.forEach(prev_match => {\n          let int = segments_intersect(prev_match[0], prev_match[1], edge[0], edge[1]);\n          if (int) {\n            found_error = true;\n            knot.add_error(int);\n            errors.push(\"There was a pair of matched-up endpoints whose matchings intersect.  The intersection point has been marked.\");\n          }\n        });\n        // then add this edge\n        matches.push([edge[0], edge[1], color]);\n      });\n    });\n\n    function do_error_stuff() {\n      console.log(\"error\");\n      // matches.forEach(match => {\n      //   knot.draw_line(null, match[0], match[1], match[2], -1);\n      // });\n      // errors.push(\"(All found matchings are drawn in on of the thinned version of the picture, to give some idea of what the program is seeing.  This can usually be edited and converted without undoing.)\");\n      knot.the_error = errors;\n      return knot;\n    }\n\n    if (found_error) {\n      return do_error_stuff();\n    }\n\n    /// Take matches and construct 4-regular planar graph\n\n    // walk_path destructively modifies buf\n    buf = new Int8Array(buf);\n\n    let verts = []; // [Point]\n    let edges = []; // [v1, v2, color, overness]\n    function vert_id(pt) {\n      for (let i = 0; i < verts.length; i++) {\n        if (Point.equal(verts[i], pt)) {\n          return i;\n        }\n      }\n      throw new Error(\"point not found\");\n    }\n\n    function walk_path(c, x, y) {\n      /* Walks the path from the given point.  Assumes path has at least two pixels. */\n      // assumes color c at point (x,y)\n\n      let pt1 = verts.length;\n      verts.push(new Point(x, y));\n      let last = null;\n      if (n_neighbors(x, y) === 2) {\n        last = pt1;\n      }\n      next_point:\n      while (buf[y*width+x] === c) {\n        buf[y*width + x] = 0;\n        for (let dy = -1; dy <= 1; dy++) {\n          for (let dx = -1; dx <= 1; dx++) {\n            if (c === buf[(y+dy)*width + (x+dx)]) {\n              x = x + dx; y = y + dy;\n              while (c === buf[(y+dy)*width + (x+dx)]) {\n                buf[y*width + x] = 0;\n                x = x + dx; y = y + dy;\n              }\n              let pt2 = verts.length;\n              verts.push(new Point(x, y));\n              edges.push([pt1, pt2, c, true]);\n              pt1 = pt2;\n              continue next_point;\n            }\n          }\n        }\n        if (last !== null) {\n          edges.push([pt1, last, c, true]);\n        }\n      }\n    }\n    // Walk from endpoints:\n    for (let y = 1; y <= height - 2; y++) {\n      for (let x = 1; x <= width - 2; x++) {\n        let c = buf[y*width+x];\n        if (c > 0 && n_neighbors(x, y) === 1) {\n          walk_path(c, x, y);\n        }\n      }\n    }\n    // Unknots:\n    for (let y = 1; y <= height - 2; y++) {\n      for (let x = 1; x <= width - 2; x++) {\n        let c = buf[y*width+x];\n        if (c > 0) {\n          walk_path(c, x, y);\n        }\n      }\n    }\n\n    // edges.forEach((edge, edge_id) => {\n    //   console.log(\"edge \" + edge + \"  v0=\"+verts[edge[0]]+\"  v1=\"+verts[edge[1]]);\n    // });\n    // console.log(\"---\");\n\n    matches.forEach(match => {\n      let seg = [vert_id(match[0]), vert_id(match[1])];\n      // Maybe seg runs through current vertices.  Split it if this is the case\n      verts.forEach((v, vi) => {\n        for (let i = 0; i + 1 < seg.length; i++) {\n          if (seg[i] === vi || seg[i+1] === vi) {\n            return;\n          }\n          if (segment_contains(verts[seg[i]], verts[seg[i+1]], v, EPSILON)) {\n            //console.log(\"Hit vertex \" + vi);\n            seg.splice(i+1, 0, vi);\n            return;\n          }\n        }\n      });\n      // Maybe seg intersects current edges.  Split both if this is the case\n      var new_edges = [];\n      edges.forEach((edge, edge_i) => {\n        for (let i = 0; i + 1 < seg.length; i++) {\n          let int_pt = segments_intersect(verts[edge[0]], verts[edge[1]],\n                                          verts[seg[i]], verts[seg[i+1]], EPSILON);\n          if (int_pt !== null) {\n            //console.log(\"Segment \" + seg +  \" hit edge \" + edge);\n            // we know int_pt is a new point if it's not an endpoint\n            let _int_pt_i = null;\n            function int_pt_i() {\n              if (_int_pt_i === null) {\n                _int_pt_i = verts.length;\n                verts.push(int_pt);\n              }\n              return _int_pt_i;\n            }\n            if (!Point.similar(int_pt, verts[edge[0]], EPSILON)\n                && !Point.similar(int_pt, verts[edge[1]], EPSILON)) {\n              new_edges.push([int_pt_i(), edge[1], edge[2], true]);\n              edge[1] = int_pt_i();\n              //console.log(\"Splitting edge\");\n            }\n            if (!Point.similar(int_pt, verts[seg[i]], EPSILON)\n                && !Point.similar(int_pt, verts[seg[i+1]], EPSILON)) {\n              seg.splice(i+1, 0, int_pt_i());\n              //console.log(\"Splitting segment\");\n            }\n            // Since seg is a straight line segment, no other part of it can intersect the current edge\n            return;\n          }\n        }\n      });\n      new_edges.forEach(e => edges.push(e));\n      for (let i = 0; i + 1 < seg.length; i++) {\n        edges.push([seg[i], seg[i+1], match[2], false]);\n      }\n    });\n\n    // now the verts and edges are constructed\n\n    /// Construct combinatorial map\n\n    // use edges as darts, but negative id means edge in the opposite direction\n    let adj_lists = [];\n    for (let i = 0; i < verts.length; i++) {\n      adj_lists[i] = [];\n    }\n    edges.forEach((edge, edge_id) => {\n      //console.log(\"edge \" + edge + \"  v0=\"+verts[edge[0]]+\"  v1=\"+verts[edge[1]]);\n      adj_lists[edge[0]].push(edge_id+1);\n      adj_lists[edge[1]].push(-edge_id-1);\n    });\n\n    let diagram = new KnotGraph(verts, edges, adj_lists);\n\n    // sort adj_lists\n    adj_lists.forEach((list, i) => {\n      if (list.length === 2) {\n        let e0 = diagram.dart_edge(list[0]), e1 = diagram.dart_edge(list[1]);\n        assert(e0[2] === e1[2]); // same color\n        return;\n      }\n      assert(list.length === 4);\n      let vert = verts[i];\n      let lverts = list.map(dart => diagram.dart_end(dart));\n      // The angles are negative since the coordinate system has inverted y due to the canvas.\n      let angles = lverts.map(vi => -pseudo_angle(vert, verts[vi]));\n      function mswap(i, j) {\n        /* maybe swap the angle and list arrays, depending on the value of the angle */\n        if (angles[i] > angles[j]) {\n          let t_angle = angles[i];\n          angles[i] = angles[j];\n          angles[j] = t_angle;\n          let t_list = list[i];\n          list[i] = list[j];\n          list[j] = t_list;\n        }\n      }\n      // sorting network\n      mswap(1,3); mswap(0,2);\n      mswap(0,1); mswap(2,3);\n      mswap(1,2);\n      for (let i = 0; i < 3; i++) {\n        if (Math.abs((angles[i] - angles[i+1] + Math.PI) % (2 * Math.PI) - Math.PI) < 1e-6) {\n          // This is an unexpected coincident pair of edges\n          found_error = true;\n          knot.add_error(vert);\n          errors.push(\"The edges around the marked vertex were unexpectly coincident.  (This error has never been observed before!)\");\n          return;\n        }\n      }\n      // Put undercrossing dart as first in adjacency list\n      if (diagram.dart_edge(list[0])[3]) {\n        list.push(list.shift());\n      }\n      // Consistency check\n      let e0 = diagram.dart_edge(list[0]),\n          e1 = diagram.dart_edge(list[1]),\n          e2 = diagram.dart_edge(list[2]),\n          e3 = diagram.dart_edge(list[3]);\n      // is it a transverse crossing?\n      if (!(!e0[3] && e1[3] && !e2[3] && e3[3]) // opposite sides are both over or under\n          || !(e0[2] === e2[2] && e1[2] === e3[2])) { // opposite sides have same color\n        found_error = true;\n        knot.add_error(vert);\n        errors.push(\"The marked crossing is not transverse.\");\n        return;\n      }\n    });\n\n    if (found_error) {\n      return do_error_stuff();\n    }\n\n    // now adj_lists contains correct rotation system for each vertex\n\n    // let the diagram choose orientations\n    diagram.ensure_orientation();\n\n    return new KnotDiagramView(this.width, this.height, diagram);\n  }\n}\n","/*\n\nThis is a version of StackBlur by Mario Klingemann, modified by Kyle Miller.\n\nOriginal copyright notice:\n\nStackBlur - a fast almost Gaussian Blur For Canvas\n\nVersion: \t0.5\nAuthor:\t\tMario Klingemann\nContact: \tmario@quasimondo.com\nWebsite:\thttp://www.quasimondo.com/StackBlurForCanvas\nTwitter:\t@quasimondo\n\nIn case you find this class useful - especially in commercial projects -\nI am not totally unhappy for a small donation to my PayPal account\nmario@quasimondo.de\n\nOr support me on flattr: \nhttps://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript\n\nCopyright (c) 2010 Mario Klingemann\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar mul_table = [\n  512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,\n  454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,\n  482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,\n  437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,\n  497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,\n  320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,\n  446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,\n  329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,\n  505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,\n  399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,\n  324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,\n  268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,\n  451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,\n  385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,\n  332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,\n  289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];\n\n\nvar shg_table = [\n\t9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, \n\t17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, \n\t19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,\n\t20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n\t21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n\t21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, \n\t22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n\t22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, \n\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, \n\t23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];\n\n\nexport function stackBlurRGB( pixels, width, height, radius ) {\n  /* pixels is a Uint8Array of length 4*width*height. */\n\n\tif ( isNaN(radius) || radius < 1 ) return;\n\tradius |= 0;\n\t\n\tvar x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum,\n\t    r_out_sum, g_out_sum, b_out_sum,\n\t    r_in_sum, g_in_sum, b_in_sum,\n\t    pr, pg, pb, rbs;\n\t\n\tvar div = radius + radius + 1;\n\tvar w4 = width << 2;\n\tvar widthMinus1  = width - 1;\n\tvar heightMinus1 = height - 1;\n\tvar radiusPlus1  = radius + 1;\n\tvar sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;\n\t\n\tvar stackStart = new BlurStack();\n\tvar stack = stackStart;\n\tfor ( i = 1; i < div; i++ ) {\n\t\tstack = stack.next = new BlurStack();\n\t\tif ( i == radiusPlus1 ) var stackEnd = stack;\n\t}\n\tstack.next = stackStart;\n\tvar stackIn = null;\n\tvar stackOut = null;\n\t\n\tyw = yi = 0;\n\t\n\tvar mul_sum = mul_table[radius];\n\tvar shg_sum = shg_table[radius];\n\t\n\tfor ( y = 0; y < height; y++ ) {\n\t\tr_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;\n\t\t\n\t\tr_out_sum = radiusPlus1 * ( pr = pixels[yi] );\n\t\tg_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );\n\t\tb_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );\n\t\t\n\t\tr_sum += sumFactor * pr;\n\t\tg_sum += sumFactor * pg;\n\t\tb_sum += sumFactor * pb;\n\t\t\n\t\tstack = stackStart;\n\t\t\n\t\tfor( i = 0; i < radiusPlus1; i++ ) {\n\t\t\tstack.r = pr;\n\t\t\tstack.g = pg;\n\t\t\tstack.b = pb;\n\t\t\tstack = stack.next;\n\t\t}\n\t\t\n\t\tfor( i = 1; i < radiusPlus1; i++ ) {\n\t\t\tp = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );\n\t\t\tr_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );\n\t\t\tg_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;\n\t\t\tb_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;\n\t\t\t\n\t\t\tr_in_sum += pr;\n\t\t\tg_in_sum += pg;\n\t\t\tb_in_sum += pb;\n\t\t\t\n\t\t\tstack = stack.next;\n\t\t}\n\t\t\n\t\t\n\t\tstackIn = stackStart;\n\t\tstackOut = stackEnd;\n\t\tfor ( x = 0; x < width; x++ ) {\n\t\t\tpixels[yi]   = (r_sum * mul_sum) >> shg_sum;\n\t\t\tpixels[yi+1] = (g_sum * mul_sum) >> shg_sum;\n\t\t\tpixels[yi+2] = (b_sum * mul_sum) >> shg_sum;\n\t\t\t\n\t\t\tr_sum -= r_out_sum;\n\t\t\tg_sum -= g_out_sum;\n\t\t\tb_sum -= b_out_sum;\n\t\t\t\n\t\t\tr_out_sum -= stackIn.r;\n\t\t\tg_out_sum -= stackIn.g;\n\t\t\tb_out_sum -= stackIn.b;\n\t\t\t\n\t\t\tp =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;\n\t\t\t\n\t\t\tr_in_sum += ( stackIn.r = pixels[p]);\n\t\t\tg_in_sum += ( stackIn.g = pixels[p+1]);\n\t\t\tb_in_sum += ( stackIn.b = pixels[p+2]);\n\t\t\t\n\t\t\tr_sum += r_in_sum;\n\t\t\tg_sum += g_in_sum;\n\t\t\tb_sum += b_in_sum;\n\t\t\t\n\t\t\tstackIn = stackIn.next;\n\t\t\t\n\t\t\tr_out_sum += ( pr = stackOut.r );\n\t\t\tg_out_sum += ( pg = stackOut.g );\n\t\t\tb_out_sum += ( pb = stackOut.b );\n\t\t\t\n\t\t\tr_in_sum -= pr;\n\t\t\tg_in_sum -= pg;\n\t\t\tb_in_sum -= pb;\n\t\t\t\n\t\t\tstackOut = stackOut.next;\n\n\t\t\tyi += 4;\n\t\t}\n\t\tyw += width;\n\t}\n\n\t\n\tfor ( x = 0; x < width; x++ ) {\n\t\tg_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;\n\t\t\n\t\tyi = x << 2;\n\t\tr_out_sum = radiusPlus1 * ( pr = pixels[yi]);\n\t\tg_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);\n\t\tb_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);\n\t\t\n\t\tr_sum += sumFactor * pr;\n\t\tg_sum += sumFactor * pg;\n\t\tb_sum += sumFactor * pb;\n\t\t\n\t\tstack = stackStart;\n\t\t\n\t\tfor( i = 0; i < radiusPlus1; i++ ) {\n\t\t\tstack.r = pr;\n\t\t\tstack.g = pg;\n\t\t\tstack.b = pb;\n\t\t\tstack = stack.next;\n\t\t}\n\t\t\n\t\typ = width;\n\t\t\n\t\tfor( i = 1; i <= radius; i++ ) {\n\t\t\tyi = ( yp + x ) << 2;\n\t\t\t\n\t\t\tr_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );\n\t\t\tg_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;\n\t\t\tb_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;\n\t\t\t\n\t\t\tr_in_sum += pr;\n\t\t\tg_in_sum += pg;\n\t\t\tb_in_sum += pb;\n\t\t\t\n\t\t\tstack = stack.next;\n\t\t  \n\t\t\tif( i < heightMinus1 )\n\t\t\t{\n\t\t\t\typ += width;\n\t\t\t}\n\t\t}\n\t\t\n\t\tyi = x;\n\t\tstackIn = stackStart;\n\t\tstackOut = stackEnd;\n\t\tfor ( y = 0; y < height; y++ ) {\n\t\t\tp = yi << 2;\n\t\t\tpixels[p]   = (r_sum * mul_sum) >> shg_sum;\n\t\t\tpixels[p+1] = (g_sum * mul_sum) >> shg_sum;\n\t\t\tpixels[p+2] = (b_sum * mul_sum) >> shg_sum;\n\t\t\t\n\t\t\tr_sum -= r_out_sum;\n\t\t\tg_sum -= g_out_sum;\n\t\t\tb_sum -= b_out_sum;\n\t\t\t\n\t\t\tr_out_sum -= stackIn.r;\n\t\t\tg_out_sum -= stackIn.g;\n\t\t\tb_out_sum -= stackIn.b;\n\t\t\t\n\t\t\tp = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;\n\t\t\t\n\t\t\tr_sum += ( r_in_sum += ( stackIn.r = pixels[p]));\n\t\t\tg_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));\n\t\t\tb_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));\n\t\t\t\n\t\t\tstackIn = stackIn.next;\n\t\t\t\n\t\t\tr_out_sum += ( pr = stackOut.r );\n\t\t\tg_out_sum += ( pg = stackOut.g );\n\t\t\tb_out_sum += ( pb = stackOut.b );\n\t\t\t\n\t\t\tr_in_sum -= pr;\n\t\t\tg_in_sum -= pg;\n\t\t\tb_in_sum -= pb;\n\t\t\t\n\t\t\tstackOut = stackOut.next;\n\t\t\t\n\t\t\tyi += width;\n\t\t}\n\t}\n}\n\nfunction BlurStack() {\n\tthis.r = 0;\n\tthis.g = 0;\n\tthis.b = 0;\n\tthis.a = 0;\n\tthis.next = null;\n}\n","// View for image import\n\nimport {assert, clamp} from \"./util.mjs\";\nimport Q from \"./kq.mjs\";\nimport {KnotRasterView} from \"./KnotRasterView.mjs\";\nimport {Point} from \"./geom2d.mjs\";\nimport {stackBlurRGB} from \"./StackBlur.mjs\";\n\nlet global_tool_state = {\n  tool: \"crop\"\n};\n\n\nexport class KnotImageImportView {\n  constructor(width, height, img) {\n    this.img = img;\n    this.width = width;\n    this.height = height;\n\n    // displacement\n    this.x = 0;\n    this.y = 0;\n\n    this.scale = Math.min(1, Math.min(width / img.width, height / img.height));\n\n    // crop region\n    this.sx = 0;\n    this.sy = 0;\n    this.swidth = img.width;\n    this.sheight = img.height;\n\n    this.invert = false;\n    this.blur = 0;\n    this.adaptive = 20;\n    this.threshold = -0.05;\n\n    this.tmp_canvas = document.createElement(\"canvas\");\n    this.tmp_canvas.width = this.width;\n    this.tmp_canvas.height = this.height;\n    this.tmp_ctxt = this.tmp_canvas.getContext(\"2d\");\n\n    this.mode_name = \"Image importing\";\n  }\n\n  copy() {\n    let view = new KnotImageImportView(this.width, this.height, this.img);\n    view.x = this.x;\n    view.y = this.y;\n    view.scale = this.scale;\n    view.sx = this.sx;\n    view.sy = this.sy;\n    view.swidth = this.swidth;\n    view.sheight = this.sheight;\n    view.invert = this.invert;\n    view.blur = this.blur;\n    view.threshold = this.threshold;\n    return view;\n  }\n\n  update_crop(pt1, pt2) {\n    let x1 = clamp(Math.min(pt1.x - this.x, pt2.x - this.x) / this.scale, 0, this.img.width),\n        x2 = clamp(Math.max(pt1.x - this.x, pt2.x - this.x) / this.scale, 0, this.img.width),\n        y1 = clamp(Math.min(pt1.y - this.y, pt2.y - this.y) / this.scale, 0, this.img.height),\n        y2 = clamp(Math.max(pt1.y - this.y, pt2.y - this.y) / this.scale, 0, this.img.height);\n\n    this.sx = x1;\n    this.sy = y1;\n    this.swidth = x2 - x1;\n    this.sheight = y2 - y1;\n  }\n\n  mousedown(pt, e, undo_stack, ctxt) {\n    let tool = global_tool_state.tool;\n    if (e.button === 2) {\n      tool = \"move\";\n      if (this.update_tool) {\n        this.update_tool(tool);\n      }\n    }\n\n    if (tool === \"crop\") {\n      this.crop_start = pt;\n      this.update_crop(this.crop_start, pt);\n      this.paint(ctxt);\n    } else if (tool === \"move\") {\n      this.move_start = pt;\n    }\n  }\n  mousemove(pt, e, undo_stack, ctxt) {\n    if (!e.buttons) {\n      this.mouseup(pt, e, undo_stack, ctxt);\n      return;\n    }\n    if (this.crop_start) {\n      this.update_crop(this.crop_start, pt);\n      this.paint(ctxt);\n    } else if (this.move_start) {\n      this.x += (pt.x - this.move_start.x);\n      this.y += (pt.y - this.move_start.y);\n      this.move_start = pt;\n      this.paint(ctxt);\n    }\n  }\n  mouseup(pt, e, undo_stack, ctxt) {\n    if (this.crop_start) {\n      this.update_crop(this.crop_start, pt);\n      this.crop_start = null;\n      this.paint(ctxt);\n    } else if (this.move_start) {\n      this.move_start = null;\n      this.paint(ctxt);\n    }\n    this.update_tool(global_tool_state.tool);\n  }\n  mouse_to_pt(pt) {\n    assert(pt instanceof Point);\n    return new Point((pt.x - this.x)/this.scale,\n                     (pt.y - this.y)/this.scale);\n  }\n  mousewheel(pt, e, undo_stack, ctxt) {\n    let delta = Math.sign(e.deltaY);\n    let kpt = this.mouse_to_pt(pt);\n    this.set_scale(this.scale * Math.pow(1.05, -delta));\n    let zkpt = this.mouse_to_pt(pt);\n    this.x += this.scale*(zkpt.x - kpt.x);\n    this.y += this.scale*(zkpt.y - kpt.y);\n    this.paint(ctxt);\n  }\n  toolbox(undo_stack, ctxt) {\n    let $div = this.$div = Q.div();\n\n    $div.append(\n      Q.div(\n        Q.span({\"data-tool\": \"move\",\n                title: \"Move image [right click]\",\n                className: \"icon-button\"},\n               Q.create(\"span\", {className: \"icon24-move\"})),\n        Q.span({\"data-tool\": \"crop\",\n                title: \"Crop image\",\n                className: \"icon-button\"},\n               Q.create(\"span\", {className: \"icon24-crop\"})),\n      )\n        .on(\"click\", e => {\n          let el = e.target.closest('.icon-button');\n          if (el) {\n            let tool = Q(el).prop('data-tool');\n            if (typeof tool === \"string\") {\n              e.preventDefault();\n              e.stopPropagation();\n              global_tool_state.tool = tool;\n              this.update_tool(tool);\n            }\n          }\n        })\n    );\n\n    this.update_tool = (toolname) => {\n      $div.query(\".icon-button\").forEach($e => {\n        let button_tool = $e.prop(\"data-tool\");\n        if (typeof button_tool === \"string\") {\n          $e.toggleClass(\"active\", button_tool === toolname);\n        }\n      });\n    };\n    this.update_tool(global_tool_state.tool);\n\n    var $scale;\n    $div.append(\n      Q.create(\"label\", {title: \"Rescale the image [mouse wheel]\"},\n               \"Scale: \",\n               $scale = Q.create(\"input\", { type: \"range\",\n                                            min: \"1\",\n                                            max: \"300\",\n                                            step: \"1\",\n                                            className: \"slider\" })\n              ));\n    $scale.on(\"input\", e => {\n      this.set_scale(e.target.value / 100);\n      this.paint(ctxt);\n    });\n\n    this.set_scale = (new_scale) => {\n      new_scale = clamp(new_scale, 0.01, 3.0);\n      $scale.value(Math.floor(this.scale * 100));\n      this.scale = new_scale;\n    };\n    this.set_scale(this.scale);\n\n    $div.append(Q.create(\"br\"));\n\n    $div.append(\n      Q.create(\"label\", { title: \"Invert the values of all the colors, for example if this is a chalk drawing.\" },\n               \"Invert colors: \",\n               Q.create(\"input\", {type: \"checkbox\"})\n               .on(\"input\", e => {\n                 this.invert = e.target.checked;\n                 this.paint(ctxt);\n               })\n              ));\n\n    $div.append(Q.create(\"br\"));\n\n    $div.append(\n      Q.create(\"label\", {title: \"Blur radius\"},\n               \"Blur: \",\n               Q.create(\"input\", { type: \"range\",\n                                   min: \"0\",\n                                   max: \"10\",\n                                   step: \"1\",\n                                   className: \"slider\" })\n               .value(this.blur)\n               .on(\"input\", e => {\n                 this.blur = e.target.value;\n                 this.paint(ctxt);\n               })\n              ));\n\n    $div.append(Q.create(\"br\"));\n\n    $div.append(\n      Q.create(\"label\", {title: \"Adaptive radius\"},\n               \"Adaptive radius: \",\n               Q.create(\"input\", { type: \"range\",\n                                   min: \"1\",\n                                   max: \"40\",\n                                   step: \"1\",\n                                   className: \"slider\" })\n               .value(this.adaptive)\n               .on(\"input\", e => {\n                 this.adaptive = e.target.value;\n                 this.paint(ctxt);\n               })\n              ));\n\n    $div.append(Q.create(\"br\"));\n\n    $div.append(\n      Q.create(\"label\", {title: \"Threshold for black\"},\n               \"Threshold: \",\n               Q.create(\"input\", {type: \"range\",\n                                  min: \"-500\",\n                                  max: \"500\",\n                                  step: \"1\",\n                                  className: \"slider\"})\n               .value(Math.floor(this.threshold * 1000))\n               .on(\"input\", e => {\n                 this.threshold = e.target.value / 1000;\n                 this.paint(ctxt);\n               })\n              ));\n\n    $div.append(Q.create(\"br\"));\n\n    $div.append(\n      Q.create(\"input\", {type: \"button\",\n                         value: \"Accept\",\n                         title: \"Take selection to painting mode\"})\n        .on(\"click\", e => {\n          this.paint(ctxt, true);\n          let view = new KnotRasterView(this.width, this.height);\n          view.fromImage(ctxt.getImageData(0, 0, this.width, this.height));\n          undo_stack.push(view);\n        })\n    );\n\n    return $div;\n  }\n\n  paint(ctxt, onlyCropped=false) {\n    ctxt.save();\n    if (onlyCropped) {\n      ctxt.fillStyle = \"#fff\";\n    } else {\n      ctxt.fillStyle = \"#ddd\";\n    }\n    ctxt.fillRect(0, 0, this.width, this.height);\n\n    let rx = this.sx*this.scale+this.x,\n        ry = this.sy*this.scale+this.y,\n        rwidth = this.swidth*this.scale,\n        rheight = this.sheight*this.scale;\n    let sx = this.sx,\n        sy = this.sy,\n        swidth = this.swidth,\n        sheight = this.sheight;\n\n    if (rx < 0) {\n      swidth += (rx) / this.scale;\n      sx = (0 - this.x) / this.scale;\n      rwidth += rx;\n      rx = 0;\n    }\n    if (rwidth > this.width) {\n      swidth -= (rwidth - this.width) / this.scale;\n      rwidth = this.width;\n    }\n    if (ry < 0) {\n      sheight += (ry) / this.scale;\n      sy = (0 - this.y) / this.scale;\n      rheight += ry;\n      ry = 0;\n    }\n    if (rheight > this.height) {\n      sheight -= (rheight - this.height) / this.scale;\n      rheight = this.height;\n    }\n\n\n    if (!onlyCropped) {\n      ctxt.globalAlpha = 0.3;\n      ctxt.drawImage(this.img,\n                     0, 0, this.img.width, this.img.height,\n                     this.x, this.y, this.scale*this.img.width, this.scale*this.img.height);\n\n      ctxt.globalAlpha = 1.0;\n      ctxt.fillStyle = \"#fff\";\n      ctxt.fillRect(rx, ry, rwidth, rheight);\n    }\n\n    let tmp_ctxt = this.tmp_ctxt;\n    tmp_ctxt.fillStyle = \"#fff\";\n    tmp_ctxt.fillRect(0, 0, rwidth + 1, rheight + 1);\n\n    tmp_ctxt.drawImage(this.img,\n                       sx, sy, swidth, sheight,\n                       0, 0, rwidth, rheight);\n\n    let imgdata = tmp_ctxt.getImageData(0, 0, Math.max(1, Math.floor(rwidth)), Math.max(1, Math.floor(rheight)));\n    let data = imgdata.data;\n\n    let width = imgdata.width;\n    let height = imgdata.height;\n\n    stackBlurRGB(data, width, height, this.blur);\n\n    let gdata = new Uint8Array(width * height);\n\n    // make grayscale (put everything into channel 1)\n    let do_invert = this.invert;\n    for (let i = 0; i < gdata.length; i++) {\n      let c = (data[4*i] + data[4*i+1] + data[4*i+2])/3;\n      if (do_invert) {\n        c = 255 - c;\n      }\n      gdata[i] = c;\n    }\n\n    stackBlurRGB(data, width, height, this.adaptive);\n\n    // threshold\n    for (let i = 0; i < gdata.length; i++) {\n      let adapt = (data[4*i] + data[4*i+1] + data[4*i+2])/3;\n      let c = gdata[i] - adapt;\n      c = (c/255 <= this.threshold) ? 0 : 255;\n      gdata[i] = c;\n    }\n\n    for (let i = 0; i < gdata.length; i++) {\n      let c = gdata[i];\n      data[4*i] = data[4*i+1] = data[4*i+2] = c;\n      data[4*i+3] = 255;\n    }\n\n    ctxt.putImageData(imgdata, rx, ry);\n\n    ctxt.restore();\n  }\n}\n","// UndoStack keeps track of changes as a list of complete views\n\nimport {assert} from \"./util.mjs\";\n\nexport class UndoStack {\n  constructor() {\n    this.versions = []; // a list of Views\n    this.i = -1;\n    this.length = 0;\n    this.listeners = [];\n  }\n  \n  _notify() {\n    this.listeners.map(f => f(this));\n  }\n  \n  get() {\n    assert(0 <= this.i && this.i < this.length);\n    return this.versions[this.i];\n  }\n  push(version) {\n    this.versions.length = this.i + 1;\n    this.versions.push(version);\n    this.i = this.versions.length - 1;\n    this.length = this.versions.length;\n    this._notify();\n  }\n  undo() {\n    if (this.i > 0) {\n      this.i--;\n      this._notify();\n    }\n  }\n  redo() {\n    if (this.i + 1 < this.versions.length) {\n      this.i++;\n      this._notify();\n    }\n  }\n}\n","import {assert} from \"./util.mjs\";\nimport \"./jones.mjs\";\nimport \"./alexander.mjs\";\nimport \"./conway.mjs\";\nimport \"./identify.mjs\";\nimport {KnotImageImportView} from \"./KnotImageImportView.mjs\";\nimport {KnotRasterView} from \"./KnotRasterView.mjs\";\nimport {UndoStack} from \"./undostack.mjs\";\nimport {WIDTH, HEIGHT} from \"./constants.mjs\";\nimport {Point} from \"./geom2d.mjs\";\nimport Q from \"./kq.mjs\";\n\nQ(function () {\n  window.addEventListener('error', function (e) {\n    let close = Q.create(\"input\", {type:\"button\", className:\"program-error-close\"}).value(\"X\");\n    let $box = Q.create(\"div\", {className:\"program-error\"},\n                        close,\n                        Q.create(\"h1\", \"Unhandled error\"),\n                        Q.create(\"p\", \"Message: \" + e.message),\n                        Q.create(\"p\", \"in \" + e.filename + \":\" + e.lineno + \":\" + e.colno),\n                        Q.create(\"p\", \"Error object: \" + JSON.stringify(e.error)));\n    Q(\"body\").append($box);\n    close.on(\"click\", e => $box.remove());\n  });\n\n  var undo_stack = new UndoStack();\n\n  undo_stack.listeners.push(undo_stack => {\n    Q(\".undo-state\").empty().append(`${undo_stack.i + 1}/${undo_stack.length}`);\n    Q(\"input.undo\").prop(\"disabled\", undo_stack.i <= 0);\n    Q(\"input.redo\").prop(\"disabled\", undo_stack.i + 1 >= undo_stack.length);    \n  });\n  Q(\"input.undo\").on(\"click\", () => {\n    undo_stack.undo();\n  });\n  Q(\"input.redo\").on(\"click\", () => {\n    undo_stack.redo();\n  });\n\n  var canvas = Q.create(\"canvas\").appendTo(Q(\"#editor\"));\n  canvas.prop(\"width\", WIDTH);\n  canvas.prop(\"height\", HEIGHT);\n\n  var ctxt = canvas[0].getContext('2d');\n  undo_stack.listeners.push(undo_stack => {\n    Q(\".modename\").empty().append(undo_stack.get().mode_name);\n    undo_stack.get().paint(ctxt);\n\n    let $tools = Q(\"#tools\").empty();\n    $tools.append(undo_stack.get().toolbox(undo_stack, ctxt));\n  });\n\n  undo_stack.push(new KnotRasterView(WIDTH, HEIGHT));\n\n  function mousePos(e) {\n    let rect = canvas[0].getBoundingClientRect();\n    return new Point(Math.floor(e.clientX - rect.left-1), Math.floor(e.clientY - rect.top-1));\n  }\n\n  var color = null;\n  var mouseHandler = null;\n\n  canvas.on(\"mousedown\", function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    undo_stack.get().mousedown(mousePos(e), e, undo_stack, ctxt);\n  });\n  canvas.on(\"mousemove\", function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    undo_stack.get().mousemove(mousePos(e), e, undo_stack, ctxt);\n  });\n  canvas.on(\"mouseup\", function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    undo_stack.get().mouseup(mousePos(e), e, undo_stack, ctxt);\n  });\n  canvas.on(\"contextmenu\", function (e) {\n    e.preventDefault();\n  });\n  canvas.on(\"wheel\", function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    let view = undo_stack.get();\n    if (view.mousewheel) {\n      view.mousewheel(mousePos(e), e, undo_stack, ctxt);\n    }\n  });\n\n  canvas.on(\"touchstart\", function (e) {\n    if (e.touches.length > 1) {\n      return;\n    }\n    e.preventDefault();\n    e.stopPropagation();\n    e.button = 0;\n    e.buttons = 1;\n    undo_stack.get().mousedown(mousePos(e.changedTouches[0]), e, undo_stack, ctxt);\n  });\n  canvas.on(\"touchmove\", function (e) {\n    if (e.touches.length > 1) {\n      return;\n    }\n    e.preventDefault();\n    e.stopPropagation();\n    e.button = 0;\n    e.buttons = 1;\n    undo_stack.get().mousemove(mousePos(e.changedTouches[0]), e, undo_stack, ctxt);\n  });\n  canvas.on(\"touchend\", function (e) {\n    if (e.touches.length > 0) {\n      return;\n    }\n    e.preventDefault();\n    e.stopPropagation();\n    e.button = 0;\n    e.buttons = 0;\n    undo_stack.get().mouseup(mousePos(e.changedTouches[0]), e, undo_stack, ctxt);\n  });\n\n\n  function process_img_upload() {\n    let img = this;\n    undo_stack.push(new KnotImageImportView(WIDTH, HEIGHT, img));\n  }\n\n  function show_drop_area(shown) {\n    Q(\"#drop-area\").css(\"display\", shown ? \"block\" : \"none\");\n  }\n\n  let drag_enter_counter = 0;\n  document.addEventListener(\"dragenter\", e => {\n    e.preventDefault();\n    e.stopPropagation();\n    drag_enter_counter++;\n    show_drop_area(drag_enter_counter > 0);\n  }, true);\n  document.addEventListener(\"dragleave\", e => {\n    e.preventDefault();\n    e.stopPropagation();\n    drag_enter_counter--;\n    show_drop_area(drag_enter_counter > 0);\n  }, true);\n  document.addEventListener(\"dragover\", e => {\n    e.preventDefault();\n    e.stopPropagation();\n    show_drop_area(true);\n  }, true);\n  document.addEventListener(\"drop\", e => {\n    e.preventDefault();\n    e.stopPropagation();\n    drag_enter_counter = 0;\n    show_drop_area(false);\n\n    let uri = e.dataTransfer.getData('text/uri-list');\n    if (uri) {\n      let uris = uri.split(\"\\n\");\n      for (let i = 0; i < uris.length; i++) {\n        if (uris[i][0] !== \"#\") {\n          let img = document.createElement(\"img\");\n          img.crossOrigin = \"Anonymous\"; // just in case the site allows it (CORS prevents most things)\n          img.onload = process_img_upload;\n          img.src = uris[i];\n          return;\n        }\n      }\n    }\n\n    let files = e.dataTransfer.files;\n    if (files.length > 0) {\n      let file = files[0];\n      let reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onloadend = () => {\n        let img = document.createElement(\"img\");\n        img.onload = process_img_upload;\n        img.src = reader.result;\n      };\n      return;\n    }\n  }, true);\n\n  document.addEventListener('paste', e => {\n    let items = (e.clipboardData || e.originalEvent.clipboardData).items;\n    for (let i = 0; i < items.length; i++) {\n      if (items[i].type.startsWith(\"image/\")) {\n        let file = items[i].getAsFile();\n        let reader = new FileReader();\n        reader.readAsDataURL(file);\n        reader.onloadend = () => {\n          let img = document.createElement(\"img\");\n          img.onload = process_img_upload;\n          img.src = reader.result;\n        };\n        return;\n      }\n    }\n  }, false);\n});\n"],"names":["assert","b","Error","remove_value","list","value","idx","indexOf","splice","equal","a","Array","constructor","length","i","compare","c","TypeError","localeCompare","escapeChar","code","charCodeAt","toString","toUpperCase","o","prototype","map","join","s","charAt","SimpleType","[object Object]","arguments","super","this","name","clamp","val","lo","hi","Math","max","min","hex_to_rgb","h","g","gcd","abs","Q","node","query","window","Element","NodeList","j","on","tag","tagname","create","props","el","document","createElement","key","append","textNode","createTextNode","withId","id","getElementById","q","querySelectorAll","forEach","e","f","appendTo","appendChild","remove","parentNode","removeChild","addClass","cls","classList","add","removeClass","toggleClass","toggle","event","handler","useCapture","events","split","addEventListener","off","removeEventListener","empty","firstChild","attr","k","v","getAttribute","setAttribute","prop","css","style","Poly","slice","pop","normalize","allow_negative","Infinity","zero","p","unshift","shift","p2","p1","fill","i1","i2","coeff","reduce","every","C1","C2","cont_gcd","content","d1","d2","normalize_and_swap","sign","d_gcd","degree","q_lead","leading_coeff","r","d","incl","mul_x","scale","make","unit","LTerm","exp","term2","Laurent","sort","t1","t2","sum","minexp","coeffs","term","variable","exp_divisor","form_exp","floor","with_neg","push","add_var","exp_offset","t","simple_mul","preserve_degree","offset","state","x","fromCoeffs","to_poly","mul","is_zero","tinv","PD","toMathematica","P","toSnappy","X","Xp","Xm","Point","y","error","dx","dy","sqrt","norm","segment_contains","segment_distance","dist","vx","vy","wx","wy","norm2","segments_intersect","q1","q2","epsilon","pt","det","lines_intersect","point_along","line_points","x1","y1","x2","y2","sx","sy","err","e2","KnotGraph","verts","edges","adjs","copy","edge","seen_darts","Set","eid","has","dart","curr_edge","dart_edge","dart_start","adj","through_dart","dart_id","dart_circuit","seen_edges","to_see","visit_edges","vid","this_sign","circ","di","bridges","dart_order","filter","dart_is_over","cr","max_colors","next_color","seen","color","deid","compact","newverts","new_vid","newedges","new_eid","newadjs","adj2","fwd","vtx_i","dart_end","e0","e1","edge0","edge1","v2","idx2","opp_dart","pixels","do_remove","next_vtx","v0","v1","pt_0","pt_1","w0x","w0y","w1x","w1y","ux","uy","cross","unsubdivide","next_dart","path","num","wr","vi","dart_oriented","matrix","Map","ensure_component","set","get","inc","c1","c2","delta","m1","m2","n","edge_i","circuit","prev_dart","component_faces","start_dart","nfaces","seifert_circuit","b_0","crossing_number","num_components","next_circuit_id","visit_component","start_edge","circuits","twists","twist_id","edge2","tw","circ_id","edge_id","circuit_adj","eid2","front","eid1","twist","tree","to_visit","cross_edges","find_twist","vecs","ce","cycle","ori1","ori2","vtx","dart1","dart2","from","to","make_vector","cross_edge","cid","vect1","vect2","link","vert1","from1","from1_front","to1","to1_front","vert2","_","from2","from2_front","to2","to2_front","linking","console","log","matrices","n_faces","plus","minus","is_black","face_fringe","adj_d","genus","oriented","dart_arc","next_arc_id","pd","edge_ids","ii","arc","concat","arc_id","arcs","code_from","dart_crossing","get_crossing","codes","parts","loops","teid","edge_arcs","arc_comps","part_verts","comp","arc_id2","vert_types","knot","comps","barycentric","skel","face_darts","darts","curr_dart","face_loop","face_dart","fresh_dart","vert_key","edge_key","face_key","dart_for","dart_remap","dart_remap_over_edge","vert","new_vert","seen_faces","face","new_knot","new_comps","skeleton","num_parts","cols","ceil","row","col","cx","cy","SUBDIV","vids","cos","PI","sin","part","outside","max_degree","vid_of_dart","row_reduce","rows","besti","l","matrixx","matrixy","is_fixed","rowx","rowy","vid2","points","vid_point","minx","maxx","miny","maxy","knot_vid_of_dart","knot_vid","TLPath","path2","TLTerm","paths","main_loop","TL","loop","k1","k2","term1","tl2","tl","invariant_caches","WeakMap","invariant_handlers","running_mts","get_invariant","diagram","args","call","cache","mt","_canceled","cancel","next_turn","Promise","resolve","reject","setTimeout","promise","async","define_invariant","NumberSystem","negate","sub_matrix","get_pd","frontier","bracket","best_count","best_eid","entity","count","div_by_loop","writhe","kb","normalized_kb","pow","jp","new_exp","FGWord","w","inverse","full_normalize","shifts","sw","gen","FGA","u","fox_deriv","Function","w2","substitute","alexander_module","pres","gens","rels","rel","ab","times","min_exp","entry","pmatrix","normalize_row","normalize_col","delete_col","delete_col_if_zero","all_zero","swap_cols","j1","j2","add_to_col","gauss_right","changed","gauss_loop","pij","deg","pij2","deg2","div","best_j","best_deg","best_leading","eliminated","eliminate_null_gens","next_gen","transpose","tpmatrix","max_attempts","reverse","old_pmatrix","simplify_presentation_matrix","alexander_polynomial","module","cur_rows","minor","do_minor_cols","next_j","minor_rows","next_i","removed_gens","simplification_round","normalize_conj","word","try_next_g","wirtinger_presentation","RatFun","is_unit","divide","f2","h1","h2","from_poly","seifert_form","A","C","pre_poly","lmatrix","from_laurent","ratfun_det","z","zpows","conway","zpow","table","self","knot_table","table_loaders","requested_files","waiting","mk_table_loader_key","components","property","get_table_loader_entry","file","loaded","needed_files","properties","files","incomplete","missing_entries","includes","get_knots","crossings","needed","_get_knots","knots","filename","src","type","getElementsByTagName","load_data","callback","keys","provides_knot_data","crossing_numbers","loaded_knot_data","to_notify","add_knot_data","data","max_crossing","conway_poly","conway_coeffs","conway_mirror","jones_poly","jones_coeffs","jones_coeffs_rev","knotdata.get_knots","names","matches","jones","obj","katlas","palette","global_tool_state","tool","default_pd_type","global_details_states","linking-matrix","seifert-matrix","alexander-module","attach_details_handler","$details","initial_state","Boolean","KnotDiagramView","width","height","zoom","mode_name","view","diag","closest","ctxt","cpt","save","fillStyle","globalAlpha","beginPath","getX","getY","restore","closest_eid","pts","strokeStyle","lineWidth","lineTo","closePath","stroke","undo_stack","mouse_to_pt","find_closest_crossing","draw_crossing_disk","find_closest_circuit","reverse_orientation","highlight_circuit","delete_component","startsWith","paint","deltaY","kpt","zkpt","$div","$tools","span","className","hex","$b","update_tool","toolname","$e","button_tool","target","preventDefault","stopPropagation","t_vert","make_alternating","title","auto_color","canvas","getContext","KnotRasterView","fromImage","getImageData","beautify","$idiv","$table","bridge_number","turaev","is_alternating","$lm","linking_matrix","$tr","$td","background","$sf","$pd","$pdtypes","pd_change","elements","dt","get_dt","laurent_invariant","then","poly","toDOM","$kb_div","$ident","res","href","$det","$jones","$conway_poly","$alex_polys","$alex_mod","with_arrows","fillRect","visit_dart","opp_is_under","to_remove","moveTo","lineCap","f_x","f_y","global_painting_state","mode","go_over","buffer","Int8Array","temp","next_knot","button","mousemove","the_color","mark_tool","shiftKey","mark_height","draw_line","pprev","pt1","pt2","data-tool","data-height","button_height","$colors","data-color","mark_color","accept","reader","FileReader","readAsDataURL","onloadend","img","onload","KnotImageImportView","result","clean_up","thin","thicken","convert","the_error","$error","imgdata","writeImage","putImageData","imageData","buf","getPixel","setPixel","getTempPixel","setTempPixel","with_radius","find_existing","p0","last_p","PAINT_RADIUS","fill_old","avoid","WIDTH","ir","tbuf","strip_errors","erase","find","nbuf","mthin","min_pcount","max_pcount","pcount","ccount","step","icount","n_neighbors","maybe_delete_spur","gas","found_error","add_error","tknot","endpoints","ep_list","errors","do_error_stuff","match","graph","all_edges","lp","score","used_points","err_points","swaps","keep_going","d3","match_up","prev_match","int","vert_id","walk_path","last","next_point","seg","new_edges","int_pt","_int_pt_i","int_pt_i","similar","adj_lists","angles","pseudo_angle","mswap","t_angle","t_list","e3","ensure_orientation","mul_table","shg_table","stackBlurRGB","radius","isNaN","yp","yi","yw","r_sum","g_sum","b_sum","r_out_sum","g_out_sum","b_out_sum","r_in_sum","g_in_sum","b_in_sum","pr","pg","pb","rbs","widthMinus1","heightMinus1","radiusPlus1","sumFactor","stackStart","BlurStack","stack","next","stackEnd","stackIn","stackOut","mul_sum","shg_sum","swidth","sheight","invert","blur","adaptive","threshold","tmp_canvas","tmp_ctxt","crop_start","update_crop","move_start","buttons","mouseup","set_scale","$scale","new_scale","checked","onlyCropped","rx","ry","rwidth","rheight","drawImage","gdata","Uint8Array","do_invert","adapt","UndoStack","versions","listeners","version","_notify","close","$box","message","lineno","colno","JSON","stringify","undo","redo","mousePos","rect","getBoundingClientRect","clientX","left","clientY","top","process_img_upload","show_drop_area","shown","toolbox","mousedown","mousewheel","touches","changedTouches","drag_enter_counter","uri","dataTransfer","getData","uris","crossOrigin","items","clipboardData","originalEvent","getAsFile"],"mappings":"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IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAC5D,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAGtDC,GAAY,CACf,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC3D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D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"}